<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zisedeqing.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基于postgresql 9.4.24源码分析。 概述pg从9.0开始支持了hot standby功能，standby支持了只读查询，大大增加了standby的资源利用率。增加hot standby的commit是：Allow read only connections during recovery, known as Hot Standby 。">
<meta property="og:type" content="article">
<meta property="og:title" content="PostgreSQL Hot Standby 源码分析">
<meta property="og:url" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="zisedeqing">
<meta property="og:description" content="基于postgresql 9.4.24源码分析。 概述pg从9.0开始支持了hot standby功能，standby支持了只读查询，大大增加了standby的资源利用率。增加hot standby的commit是：Allow read only connections during recovery, known as Hot Standby 。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%9E%B6%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/transaction-tracking.png">
<meta property="og:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/standby-state.png">
<meta property="og:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/snapshot.png">
<meta property="og:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/pg_stat_database_conflicts.png">
<meta property="article:published_time" content="2021-02-07T03:35:53.000Z">
<meta property="article:modified_time" content="2021-02-07T06:40:45.083Z">
<meta property="article:author" content="zisedeqing">
<meta property="article:tag" content="postgresql">
<meta property="article:tag" content="standby">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%9E%B6%E6%9E%84%E5%9B%BE.png">

<link rel="canonical" href="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>PostgreSQL Hot Standby 源码分析 | zisedeqing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zisedeqing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zisedeqing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-favorite">

    <a href="/favorite" rel="section"><i class="fa fa-star fa-fw"></i>收藏夹</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zisedeqing.github.io/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zisedeqing">
      <meta itemprop="description" content="Postgresql 技术博客，欢迎交流">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zisedeqing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PostgreSQL Hot Standby 源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-07 11:35:53 / 修改时间：14:40:45" itemprop="dateCreated datePublished" datetime="2021-02-07T11:35:53+08:00">2021-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/postgresql/" itemprop="url" rel="index"><span itemprop="name">postgresql</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基于postgresql 9.4.24源码分析。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>pg从9.0开始支持了hot standby功能，standby支持了只读查询，大大增加了standby的资源利用率。增加hot standby的commit是：<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/commit/efc16ea520679d713d98a2c7bf1453c4ff7b91ec">Allow read only connections during recovery, known as Hot Standby</a> 。<a id="more"></a></p>
<p>其实现的根基依然是流复制，基于流复制，提供只读能力。简单来说就是startup进程持续不断的redo master上的xlog，并根据xlog跟踪master上事务的运行状态，构建类似于master上的活跃事务链表(KnownAssignedXids)。hot standby上的backend 通过KnownAssignedXids生成事务快照，执行只读查询。</p>
<p>其整体架构图如下：<br>   <img src="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="架构图"></p>
<p>master节点核hot standby节点通过流复制建立数据关联，master node事务持续的更改数据，并写入xlog。通过流复制协议，日志不断的同步到hot standby节点。hot standby在接收到master的日志后，由startup进程replay，并跟踪master上事务状态，记录到running transaction list中。从上图可以hot standby的startup进程有2个新的模块，transaction tracking和lock manager。</p>
<p>transaction tracking用来跟踪master上事务的状态，记录master上正在运行的事务，这样就可以在hot standby提供MVCC的功能。</p>
<p>lock manager用来记录所有对象的AccessExclusiveLock锁。正常情况下hot standby的backend最多会RowExclusiveLock或者更低的锁，所以一般不会与其他backend或者startup进程冲突，除非是AccessExclusiveLock锁。因此为了解决这些冲突，hot standby使用一个hashmap用来记录所有的AccessExclusiveLock。后面会有详细的分析。</p>
<p>从这个可以看出master与hot standby只通过xlog进行数据复制，因此所有需要在standby做的操作，必须记录到xlog中，所有hot standby模式下，master上日志的量也会比其他模式要多一些。</p>
<h1 id="transaction-tracking"><a href="#transaction-tracking" class="headerlink" title="transaction tracking"></a>transaction tracking</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>hot standby通过模拟master上的事务，来提供只读事务的MVCC机制，简单来说就是通过xlog，重构master上事务的启动、结束过程，在共享内存中记录所有master上running的事务，以此为根据，来给hot standby上的只读事务提供MVCC的snapshot。</p>
<p>hot standby 使用KnownAssignedXids实现上面的功能，这是一个有序的数组，通过redo XLOG_RUNNING_XACTS 日志进行初始化，在Startup redo 每条xlog record时，把xlog record记录的xid加入到KnownAssignedXids，来做到持续的跟踪。在遇到commit、abort日志时，从KnownAssignedXids中移除，来模拟事务的提交。因此可以把KnownAssignedXids看做master上的PgXacts 数组，是master活跃事务的一个快照。<br><img src="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/transaction-tracking.png" alt="transaction tracking"></p>
<ol>
<li>在hot standby启动时， 创建KnownAssignedXids。</li>
<li>startup 不断的读取xlog record，并redo，并把扫描到的新的xid加入KnownAssignedXids<ol>
<li>一般的xlog record，在日志头记录xid，添加到KnownAssignedXids。该过程是模拟master上的begin操作。</li>
<li>遇到commit/abort 日志，把事务对应的xid和subxid从KnownAssignedXids中删除，该过程模式master上的commit/abort.</li>
<li>shutdown checkpoint日志:根据checkpoint日志构造 running xacts信息，并apply到KnownAssignedXids中。这是因为当遇到shutdown checkpoint时，表明此刻在master上除了2pc之外，已经没有任何running事务了。构造一个空的running xacts信息，用于清理KnownAssignedXids中的事务。</li>
<li>running xacts日志：master定期写入的日志，用于反映某一时刻master上事务的状态。这个日志在下面会详细介绍。有几个作用：<ul>
<li>用于在hot standby上构建一个一致点，在这个点之后hot standby即可以接受只读查询。</li>
<li>清理master上已经结束的事务。有些事务没有显示的abort，依赖该日志定期清理。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="standby-state状态机"><a href="#standby-state状态机" class="headerlink" title="standby state状态机"></a>standby state状态机</h2><p>hot standby 在startup进程维护了一个状态机，用于标志hot standby处于哪个状态，需要做哪些事情，如下图所示：<br><img src="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/standby-state.png" alt="standby state"></p>
<ol>
<li>状态机总共有4个状态：<ul>
<li>STANDBY_DISABLED：默认值，表示没有开启hot standby</li>
<li>STANDBY_INITIALIZED：已经执行完hot standby的初始化工作，比如创建了RecoveryLockLists，为startup分配了vxid等。此时还不能接受readonly 查询</li>
<li>STANDBY_SNAPSHOT_READY：hot standby已经可以接受read only查询</li>
<li>STANDBY_SNAPSHOT_PENDING：hot standby已经有部分running xacts，但是不完整，还不能接受read only 查询。</li>
</ul>
</li>
<li>STANDBY_DISABLED –&gt; STANDBY_INITIALIZED<br>startup 在redo xlog之前进入STANDBY_INITIALIZED状态。</li>
<li>STANDBY_INITIALIZED –&gt; STANDBY_SNAPSHOT_READY<br>正常情况下，在hot standby redo XLOG_RUNNING_XACTS日志后，即可构造出一个master上running xacts的快照，此时状态转换成STANDBY_SNAPSHOT_READY，接受只读查询。</li>
<li>STANDBY_INITIALIZED –&gt; STANDBY_SNAPSHOT_PENDING:<br>hot standby在redo XLOG_RUNNING_XACTS日志时，如果master上subxid发生溢出了，则此时会进入STANDBY_SNAPSHOT_PENDING。这表示hot standby上没有全部的master running xacts信息，hot standby正在等待完整的master snapshot。</li>
<li>STANDBY_SNAPSHOT_PENDING –&gt; STANDBY_SNAPSHOT_READY<br>在下一个XLOG_RUNNING_XACTS日志之前，如果发现上一个snapshot中所有为记录的事务，已经结束了，这表示hot standby上已经有完整master 完整的running xacts了，所以可以进入STANDBY_SNAPSHOT_READY状态，接受只读查询。这个是一个优化，为了防止master上sub xids总是溢出，导致standby长时间无法进入ready状态。</li>
<li>STANDBY_SNAPSHOT_PENDING –&gt; STANDBY_INITIALIZED<br>redo 下一个XLOG_RUNNING_XACTS，如果该日志记录的事务为空，或者没有subxid溢出，则转换成STANDBY_INITIALIZED。表示使用该日志记录的running xacts作为hot standby的snapshot。之后就会从STANDBY_INITIALIZED切换到STANDBY_SNAPSHOT_READY。</li>
</ol>
<p>从上面的状态机转换可以看出，hot standby接受只读查询的一个必要条件是：在某一时刻，standby有master上完整的running xacts视图。即standby在这一时刻看到的数据是一致的。之后可以通过redo xlog，模拟master事务的开启和结束，也可以看到一致的数据。</p>
<p>✅遗留问题：<br>在master 子事务溢出时，master还是会把所有顶层事务记录到日志中的，那么standby也是有所有顶层事务的xid的，为啥这种情况下standby无法接受只读查询？<br>按理说，子事务的可见性判断只会依赖于顶层事务，如果顶层事务没有提交，在standby上应该是看不到这些子事务的修改的，所以应该不会影响standby snapshot的生成才对。<br>我的理解是：子事务在修改tuple时，记录的xid是子事务的xid，在事务可见性判断时，无法区分xid是子事务，还是顶层事务，无法记录的不全，则会影响事务的可见性 判断。<br>standby在正常情况下，不会维护pg_subtrans，master上是在AssignTransactionId时维护的，但是standby上没有，只能在redo XLOG_XACT_ASSIGNMENT时，才把溢出的sub事务记录到pg_subtrans。所以如果初始化的snapshot不包含所有的sub xid，对事务可见性判断时有影响的。</p>
<h2 id="XLOG-RUNNING-XACTS"><a href="#XLOG-RUNNING-XACTS" class="headerlink" title="XLOG_RUNNING_XACTS"></a>XLOG_RUNNING_XACTS</h2><p>为实现hot standby新添加的wal日志类型，用来记录master上某一时刻running xacts的视图。该日志有2个作用：</p>
<ol>
<li>standby 处于STANDBY_INITIALIZED或者STANDBY_SNAPSHOT_PENDING状态时，在standby上构建一个master 某一时刻完整的running xacts视图，标记hot standby可以进入read only。</li>
<li>standby 处于STANDBY_SNAPSHOT_READY时，可以清理standby上残留的事务以及锁。这个是由于master上有些事务可能是没有显示commit、abort日志的，这些事务在standby可以通过master上定期的XLOG_RUNNING_XACTS日志，来进行清理。</li>
</ol>
<p>✅<strong>master端记录</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xl_running_xacts</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>         xcnt;           <span class="comment">/* # of xact ids in xids[] */</span></span><br><span class="line">    <span class="keyword">int</span>         subxcnt;        <span class="comment">/* # of subxact ids in xids[] */</span></span><br><span class="line">    <span class="keyword">bool</span>        subxid_overflow;    <span class="comment">/* snapshot overflowed, subxids missing */</span></span><br><span class="line">    TransactionId nextXid;      <span class="comment">/* copy of ShmemVariableCache-&gt;nextXid */</span></span><br><span class="line">    TransactionId oldestRunningXid;     <span class="comment">/* *not* oldestXmin */</span></span><br><span class="line">    TransactionId latestCompletedXid;   <span class="comment">/* so we can set xmax */</span></span><br><span class="line">    TransactionId xids[<span class="number">1</span>];      <span class="comment">/* VARIABLE LENGTH ARRAY */</span></span><br><span class="line">&#125; xl_running_xacts;</span><br><span class="line">调用栈如下：</span><br><span class="line">LogCurrentRunningXacts</span><br><span class="line">    LogStandbySnapshot</span><br><span class="line">        CreateCheckPoint</span><br><span class="line">        BackgroundWriterMain <span class="comment">// 定期执行：LOG_SNAPSHOT_INTERVAL_MS=15000 ms</span></span><br><span class="line">        SnapBuildWaitSnapshot <span class="comment">// logical decoding</span></span><br><span class="line">        ReplicationSlotReserveWal <span class="comment">// logical decoding</span></span><br></pre></td></tr></table></figure>
<ol>
<li>记录的内容：<ul>
<li>master调用GetRunningTransactionData函数，遍历ProcArray，收集所有正在运行的事务</li>
<li>xcnt： 所有running事务的个数，包含子事务</li>
<li>subxcnt: running子事务的个数</li>
<li>nextXid：master上下一个xid的值，实际是ShmemVariableCache-&gt;nextXid</li>
<li>oldestRunningXid：正在运行的最小的事务id</li>
<li>latestCompletedXid：已经结束的最大事务id，可以理解成snapshot的xmax。实际是ShmemVariableCache-&gt;latestCompletedXid</li>
<li>xids：running的事务id。包含子事务，该结构在分配时size是：(PGPROC_MAX_CACHED_SUBXIDS + 1) * PROCARRAY_MAXPROCS。</li>
<li>subxid_overflow：表示当前snapshot是否发生了子事务的溢出。<br>postgres规定，每个backend最多可以cached PGPROC_MAX_CACHED_SUBXIDS个子事务，即64，如果一个事务有超过64个子事务，则会发生溢出。此时snapsh只记录顶层事务id，不记录子事务。</li>
</ul>
</li>
<li>记录的时间点，在不考虑logical decoding时，只有2处记录：<ul>
<li>非shutdown(包含end of recovery)checkpoint时记录</li>
<li>bgwriter 每个15s记录一次(如果xlog没有变化也不会记录)</li>
<li>这里比较奇怪，既然有bgwriter每隔15s记录一次，为啥checkpoint时还有记录，感觉只留一个即可<br>之前是只有在checkpoint时才做的，后来由于checkpoint频率比较低，可能会导致standby比较长的时间无法进入ready状态，所以也在bgwriter记录。代码commit是：ed46758381ff63a422fcb0b1f2763eb13273640f</li>
</ul>
</li>
</ol>
<p>✅<strong>standby端redo</strong><br>standby 在读取到XLOG_RUNNING_XACTS日志后，开始redo该日志，相应的standby状态机也会发生转变。redo主要操作在函数ProcArrayApplyRecoveryInfo内完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ExpireOldKnownAssignedTransactionIds(oldestRunningXid);</span><br><span class="line">StandbyReleaseOldLocks</span><br><span class="line"><span class="keyword">if</span> STANDBY_SNAPSHOT_READY then <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> is STANDBY_SNAPSHOT_PENDING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> subxid_overflow <span class="keyword">and</span> xcnt == <span class="number">0</span></span><br><span class="line">        KnownAssignedXidsReset</span><br><span class="line">        重置standbyState为STANDBY_INITIALIZED</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> standbySnapshotPendingXmin &lt; oldestRunningXid</span><br><span class="line">            standbyState 转换为STANDBY_SNAPSHOT_READY</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// standbyState must be STANDBY_INITIALIZED</span></span><br><span class="line">初始化KnownAssignedXids</span><br><span class="line">    去掉已经提交和回滚的事务，并且KnownAssignedXids是有序的</span><br><span class="line">ExtendSUBTRANS to nextXid</span><br><span class="line"><span class="keyword">if</span> running-&gt;subxid_overflow</span><br><span class="line">    standbyState = STANDBY_SNAPSHOT_PENDING</span><br><span class="line">    standbySnapshotPendingXmin = latestObservedXid;</span><br><span class="line">    procArray-&gt;lastOverflowedXid = latestObservedXid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    standbyState = STANDBY_SNAPSHOT_READY;</span><br><span class="line">ShmemVariableCache-&gt;latestCompletedXid = running-&gt;latestCompletedXid</span><br><span class="line">初始化ShmemVariableCache-&gt;nextXid为latestObservedXid</span><br></pre></td></tr></table></figure>
<p>主要作用是在standby上构建master上某一时刻的snapshot，进入一致状态，接受只读查询。在处于ready状态后，该日志的作用就是用来释放残留在standby上的事务，以及持有的锁。这些事务一般是没有commit、abort日志的事务。</p>
<h2 id="hot-standby-snapshot的创建"><a href="#hot-standby-snapshot的创建" class="headerlink" title="hot standby snapshot的创建"></a>hot standby snapshot的创建</h2><p>standby上一个只读查询生成snapshot，也是在GetSnapshotData函数中，与master的不同之处是：master是遍历ProcArray数组，而standby则是遍历KnownAssignedXids。KnownAssignedXids数组是一个有序的数组，因此在遍历是效率应该会比ProcArray高一些。</p>
<ol>
<li>xmax=ShmemVariableCache-&gt;latestCompletedXid</li>
<li>xmin和xids: 遍历KnownAssignedXids中每一个有效的xid，计算xmin和xids。由于是有序的，所以可以不用完全遍历，在xmax之后的即可忽略。<br>这里会把所有running的xid存储在subxip里面，而不是xip。这样做的原因是standby无法区分哪些是子事务，所以都存储在subxip里面了。对应的XidInMVCCSnapshot也做了一些修改。</li>
</ol>
<h2 id="事务可见性判断"><a href="#事务可见性判断" class="headerlink" title="事务可见性判断"></a>事务可见性判断</h2><p>基本与master一样，不同之处就是standby的snapshot所有的xid都记录在snapshot-&gt;subxip里面，因此实现流程有所调整，具体实现在代码XidInMVCCSnapshot。<br><img src="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/snapshot.png" alt="snapshot"><br>先判断是否有子事务溢出，如果有的话，则根据pg_subtrans找到顶层事务，通过顶层事务，判断事务是否在snapshot内。否则，直接遍历snapshot-&gt;subxip，判断事务是否在snapshot内。</p>
<h2 id="KnownAssignedXids"><a href="#KnownAssignedXids" class="headerlink" title="KnownAssignedXids"></a>KnownAssignedXids</h2><p>KnownAssignedXids是hot standby上维护的一个非常重要的数组，上面所有关于master上事务跟踪的实现，都是基于该数组的。KnownAssignedXids里面记录的事务，表示在该时刻上master上runnig的事务。</p>
<p>standby记录所有已经分配过xid，包括wal日志中记录的xid，以及哪些没有显示记录但是可以推断出来的xid(是哪些？刚分配了xid，未做任何数据修改之前挂了？还有就是先分配了xid，但是xlog没有写进wal，后分配的xid的xlog先写进xlog里面了)。之所以能够推断出unobserved xid，是因为xid是顺序分配，并且是连续的。当发现或者推断出新的xid时，会扩展KnownAssignedXids，当xid结束时，在缩小KnownAssignedXids。</p>
<p>在记录时，没有区分顶层事务的xid和子事务的xid，这些都一起存储在KnownAssignedXids中。backend 在GetSnapshotData时把这些xid 复制到snapshot中，XidInMVCCSnapshot也不区分父事务和子事务。sub xid被视为顶层事务，并且在典型场景下pg_subtrans 也不会维护，但是这并不影响可见性。</p>
<p>这也带来一个问题，如果一个事务的子事务非常多的话，KnownAssignedXids也可能会溢出的，因此master会在sub xids &gt; PGPROC_MAX_CACHED_SUBXIDS时记录XLOG_XACT_ASSIGNMENT 日志，standby在redo时，会把sub xid从KnownAssignedXids中移除，并把顶层xid与sub xid的关系记录到pg_subtransa中。这样做的代价就是TransactionIdIsInProgress判断时将会变慢。<br>使用latestObservedXid来记录最近从KnownAssignedXids中移除的subxid。</p>
<p>在master的backend在记录abort日志之前无故消失，那么这些xid依然保留在KnownAssignedXids中。虽然这些事务已经结束了，但是standby仍然认为他们是running的。这样是没有问题的，因为无论怎么样，这些事务所做的修改，在standby上是不可见的。（是否会影响ddl的执行？）这些xid会在redo XLOG_RUNNING_XACTS日志时从KnownAssignedXids中移除，来避免KnownAssignedXids的溢出。</p>
<p>✅<strong>一些接口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExpireTreeKnownAssignedTransactionIds</span><br><span class="line">ExpireOldKnownAssignedTransactionIds</span><br><span class="line">KnownAssignedXidsGetAndSetXmin</span><br><span class="line">KnownAssignedXidsGetOldestXmin</span><br><span class="line">KnownAssignedXidsGetAndSetXmin</span><br></pre></td></tr></table></figure>
<p>✅<strong>一些全局变量</strong></p>
<ol>
<li>KnownAssignedXids<br>一个有序的数组，用来存储所有running的事务id，包含子事务。该数值中间是有空洞的，使用KnownAssignedXidsValid来标记数组中哪些位置是有效的xid</li>
<li>latestObservedXid<br>记录在wal中出现的最近的并且是最”新的”一个xid，比如两个xid 6和7，日志的顺序是先出现7，后出现6，则latestObservedXid的值为7.<br>这个xid的作用是用来推断没有显示出现的running xid 的。在ProcArrayApplyRecoveryInfo和RecordKnownAssignedTransactionIds中，都会与latestObservedXid比较，把xid与latestObservedXid之前的xid也作为running xid记录到KnownAssignedXids中。</li>
<li>standbySnapshotPendingXmin<br>不在KnownAssignedXids中的，并且running的最大的xid。只有STANDBY_SNAPSHOT_PENDING时记录，状态转换后，就没有用了。增加这个全局变量的原因是：hot standby在ready之前，如果发现了subxid_overflow 的snapshot，则会进入STANDBY_SNAPSHOT_PENDING状态，如果一直遇到subxid_overflow的snapshot的话，可能会导致hot standby无法进入ready状态。所以增加了该变量来跟踪不在KnownAssignedXids中的running的xid，如果发现该xid已经结束了，则hot standby可以切换到ready状态。之所以可以切换的原因是这些不在KnownAssignedXids中的事务都已经结束了，所以也没有必要记录到KnownAssignedXids中，所以这个subxid_overflow的snapshot也是有效的了。</li>
</ol>
<p>✅ <strong>unobserved xids</strong><br>在hot standby中有一个次出现多次， 字面的意思是未被”看到”的xid。这个”看到”的意思我理解是在xlog redo时，从日志中看到。所以未被“看到”应该是说没有出现在xlog中的xid。那在pg中有哪些情况可能会出现这种状况呢？</p>
<ol>
<li>master上事务开启并分配了xid，但是在修改任何数据之前，事务结束了，并且没有记录abort或者commit日志。比如kill掉backend，或者FATAL 异常等</li>
<li>假设2个事务xid=6和xid=7，事务6在分配xid后，wal log写入之前，事务7的wal log先写入，并同步到standby上了，这是standby在redo的时候，会发现xid=7的事务，但是xid=6的事务没有，此时xid=6的事务就是unobserved xid.<br>但是上面这2中情况貌似对hot standby没有影响，因为这些事务的修改还都没有出现在hot standby上。</li>
<li>pg数据的修改是先修改数据page，然后在记录wal log，如果在修改完page，并且wal log flush到xlog之前，page写入磁盘了，然后这个page在basebackup时，copy到standby上。xlog没有过去，好像这种情况不会发生？</li>
<li>应该还有会影响hot standby可见性的情况，但是没有想到？？？</li>
</ol>
<h1 id="standby冲突解决方案"><a href="#standby冲突解决方案" class="headerlink" title="standby冲突解决方案"></a>standby冲突解决方案</h1><p>引入hot standby后，master与standby会存在几种冲突，导致一些问题，这些冲突如下：</p>
<ol>
<li>AccessExclusiveLock锁冲突：lock table或者DDL<br>比如master上执行drop table，执行完后，日志同步到standby，但是standby上以一个长事务在访问该表，则drop table 操作如何处理？等待只读事务结束？要等多久？</li>
<li>master上删除表空间，但是standby上有查询读取这些表空间的临时文件</li>
<li>master上删除database，但是standby上还有连接连上这些database</li>
<li>master上vacuum 清理的tuple或者page，standby有事务还需要读取</li>
</ol>
<p>这些冲突，因为在master上已经发生，所以无法取消，但是也不能让standby无限等待下去，不然standby就会落后比较多的日志，所以这里就提出了一直机制，可以识别这些冲突，并可以强制取消standby上的查询。<br>按上面的描述，可以把冲突分为两类，不同类型的冲突解决方案不同，下面分别阐述。</p>
<h2 id="锁冲突"><a href="#锁冲突" class="headerlink" title="锁冲突"></a>锁冲突</h2><p>我们把data 链接和tablespace文件也归类到锁冲突这里，database和tablespace的处理比较简单，具体处理逻辑分别在ResolveRecoveryConflictWithDatabase和ResolveRecoveryConflictWithTablespace中。</p>
<p><strong>ResolveRecoveryConflictWithDatabase：</strong><br>遍历backend，把链接该database的所有backend 结束掉。<br><strong>ResolveRecoveryConflictWithTablespace：</strong>由于无法精确的知道哪些事务会使用这些tablespace，所以目前的做法是cancel所有的backend。</p>
<p>下面重点说一下AccessExclusiveLock的冲突。在standby上正常的backend只有读取权限，所有的数据修改都在startup进程完成，在startup进程上维护了一个hashmap RecoveryLockLists，记录了所有事务持有的AccessExclusiveLock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RecoveryLockListsEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TransactionId xid;</span><br><span class="line">    List       *locks;</span><br><span class="line">&#125; RecoveryLockListsEntry;</span><br></pre></td></tr></table></figure>
<p>RecoveryLockLists的key是xid，entry是持有的lock链表。该链表的维护操作如下：</p>
<ol>
<li>初始化在InitRecoveryTransactionEnvironment函数，在redo xlog之前完成初始化操作，包括为startup进程分配vxid</li>
<li>请求AccessExclusiveLock：StandbyAcquireAccessExclusiveLock<br>master在任何持有AccessExclusiveLock的时候，会把加锁信息记录到wal中，并通过日志的形式同步到standby。standby通过redo XLOG_STANDBY_LOCK来完成加锁。加锁时先把锁信息记录到RecoveryLockLists中，然后在调用LockAcquireExtended完成真正的锁定。如果这里发生发现冲突，则调用ResolveRecoveryConflictWithLock接口，解开冲突。</li>
<li>在事务提交或者回滚时释放持有的锁：StandbyReleaseLockTree/StandbyReleaseAllLocks</li>
<li>释放残留的锁：StandbyReleaseOldLocks<br>与事务一样，锁也可能会在standby上残留，比如事务已经结束，但是没有记录xlog。这些锁依靠master记录的事务snapshot来释放，既释放残留的事务，也释放残留的锁。这里一般会有15s的延迟，所有如果ddl的事务异常结束，没有记录abort日志的话，对standby的影响还是比较大的。<br>锁冲突的解决策略：</li>
<li>database类型的话，会立即结束backend</li>
<li>tablespace与AccessExclusiveLock的处理方式是一样的，最终调用ResolveRecoveryConflictWithVirtualXIDs接口来处理冲突：<ul>
<li>处理的方式是把冲突的backend给cancel掉</li>
<li>cancel的时机也很重要：可以使用2个参数来控制max_standby_archive_delay和max_standby_streaming_delay<ul>
<li>max_standby_archive_delay：用来控制归档恢复时的参数</li>
<li>max_standby_streaming_delay：用来控制streaming的hot standby是的参数<br>这2个参数都是所说在等待多久后cancel掉backend的。实际上也可以理解长在冲突时，standby落后master数据的时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="vacuum冲突"><a href="#vacuum冲突" class="headerlink" title="vacuum冲突"></a>vacuum冲突</h2><p>在vacuum、visibilitymap以及scan时page的整理，都可能会清理在standby上还需要的tuple。这些tuple在master可能已经没有人可见了，但是在standby上可能还有事务查询，这就造成了snapshot的冲突。<br>下面记录了会造成snapshot冲突的点，master都会记录对应的日志，便于standby来处理这些冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">XLOG_HEAP2_CLEAN  heap_xlog_clean</span><br><span class="line">    记录latestRemovedXid：删除的tuple中xid最大的，在standby用于判断哪些是冲突的事务:在latestRemovedXid之前的事务都是冲突的。</span><br><span class="line">    lazy_vacuum_page：vacuum时调用</span><br><span class="line">    heap_page_prune: 清理某个页面内的垃圾元组，一般是在scan是调用。</span><br><span class="line">XLOG_HEAP2_CLEANUP_INFO  heap_xlog_cleanup_info</span><br><span class="line">    vacuum时，用来记录清理的dead tuple，与上面一样也会记录latestRemovedXid</span><br><span class="line">XLOG_HEAP2_VISIBLE heap_xlog_visible</span><br><span class="line">    visibilitymap用的，标记页面上的所有tuple都可见。</span><br><span class="line">    记录cutoff_xid：表示当前页面上最大的xmin，即该xid之后的事务都可见。</span><br><span class="line">XLOG_HEAP2_FREEZE_PAGE heap_xlog_freeze_page</span><br><span class="line">    vacuum freeze时用的，与XLOG_HEAP2_VISIBLE一样记录cutoff_xid。</span><br><span class="line">XLOG_BTREE_DELETE btree_xlog_delete</span><br><span class="line">    vacuum btree index时记录，在redo时会遍历删除的所有index tuple指向的tuple来计算latestRemovedXid。</span><br><span class="line">XLOG_BTREE_REUSE_PAGE btree_xlog_reuse_page</span><br><span class="line">    在重用一个btree page时记录，一般是在scan时。记录latestRemovedXid。</span><br><span class="line">XLOG_SPGIST_VACUUM_REDIRECT spgRedoVacuumRedirect</span><br><span class="line">    记录newestRedirectXid</span><br></pre></td></tr></table></figure>
<p>这种类型的冲突解决在ResolveRecoveryConflictWithSnapshot函数中处理，根据记录的xid，找到冲突的事务，然后cancel掉这些事务。<br>另一个冲突时bufferpin的冲突，也是由于dead tuple清理导致的，由ResolveRecoveryConflictWithBufferPin来处理。buffer pin在standby上还可能会造成死锁，由CheckRecoveryConflictDeadlock来检查死锁。</p>
<p><strong>冲突解决的策略：</strong></p>
<ol>
<li>与锁冲突一样，cancel 冲突的backend，保证redo的顺利进行。cancel策略也一样，使用max_standby_archive_delay和max_standby_streaming_delay。</li>
<li>hot_standby_feedback：master在清理dead tuple时，把standby上的事务也考虑在内，这样就不会出现snapshot冲突。但是缺点就是会延迟master 垃圾tuple的清理速度，导致表膨胀。</li>
<li>在master配置vacuum_defer_cleanup_age。与2类似，也是延迟清理master上的dead tuple。但是该方法无法保证确切的时间窗口。好处是master上表的膨胀会在可控范围。</li>
</ol>
<h2 id="XLOG-STANDBY-LOCK"><a href="#XLOG-STANDBY-LOCK" class="headerlink" title="XLOG_STANDBY_LOCK"></a>XLOG_STANDBY_LOCK</h2><p>master在需要持有AccessExclusiveLock时，记录该日志，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LogAccessExclusiveLocks</span><br><span class="line">    LogStandbySnapshot</span><br><span class="line">        CreateCheckPoint</span><br><span class="line">        BackgroundWriterMain <span class="comment">// 定期执行：LOG_SNAPSHOT_INTERVAL_MS=15000 ms</span></span><br><span class="line">        SnapBuildWaitSnapshot <span class="comment">// logical decoding</span></span><br><span class="line">        ReplicationSlotReserveWal <span class="comment">// logical decoding</span></span><br><span class="line">    LogAccessExclusiveLock</span><br><span class="line">        LockAcquireExtended <span class="comment">// AccessExclusiveLock &amp;&amp; </span></span><br><span class="line">                            <span class="comment">// LOCKTAG_RELATION &amp;&amp; is master &amp;&amp; </span></span><br><span class="line">                            <span class="comment">// enable hot standby</span></span><br></pre></td></tr></table></figure>
<ol>
<li>LogStandbySnapshot<ul>
<li>gwriter进程，定期执行，时间间隔是15s</li>
<li>CreateCheckPoint，在非CHECKPOINT_END_OF_RECOVERY和CHECKPOINT_IS_SHUTDOWN类型的checkpoint日志中记录</li>
<li>logical decoding相关的</li>
</ul>
</li>
<li>LockAcquireExtended，在master请求AccessExclusiveLock锁<br>checkpoint和bgwriter记录的日志，主要是用来清理残留锁的。</li>
</ol>
<h2 id="pg-stat-database-conflicts"><a href="#pg-stat-database-conflicts" class="headerlink" title="pg_stat_database_conflicts"></a>pg_stat_database_conflicts</h2><p>该视图用来记录每个database遇到的每种类型的冲突次数。<br><img src="/2021/02/07/PostgreSQL-Hot-Standby-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/pg_stat_database_conflicts.png" alt="pg_stat_database_conflicts"></p>
<h1 id="hot-standby上的数据新鲜度"><a href="#hot-standby上的数据新鲜度" class="headerlink" title="hot standby上的数据新鲜度"></a>hot standby上的数据新鲜度</h1><p>这里说明一下，在hot standby上只读查询能够看到的数据是什么时候的。按流复制的实现看，有几个参数可以用来控制hot standby上的数据：</p>
<ol>
<li>synchronous_standby_names<br>该参数用来控制standby是异步的还是强同步的，对于hot standby也是可以配置成异步的。如果配置成异步的话，其数据新鲜度基本上是没有任何保障的，在master压力大的情况下，hot standby可能会落后非常多的数据。<br>如果配置成强同步，则至少可以保证，master上已经提交的事务，其日志一定会同步的hot standby，但是也只能保证是同步过去了，无法保证hot standby及时的applay了。所以也是可能会造成查询的数据落后的。具体的时间不好估算。</li>
<li>synchronous_commit<br>上面的参数是控制xlog什么时候同步到standby上。这个参数则可以控制的更精细：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SYNCHRONOUS_COMMIT_OFF,     <span class="comment">/* asynchronous commit */</span></span><br><span class="line">    SYNCHRONOUS_COMMIT_LOCAL_FLUSH,     <span class="comment">/* wait for local flush only */</span></span><br><span class="line">    SYNCHRONOUS_COMMIT_REMOTE_WRITE,    <span class="comment">/* wait for local flush and remote</span></span><br><span class="line"><span class="comment">                                         * write */</span></span><br><span class="line">    SYNCHRONOUS_COMMIT_REMOTE_FLUSH,    <span class="comment">/* wait for local and remote flush */</span></span><br><span class="line">    SYNCHRONOUS_COMMIT_REMOTE_APPLY     <span class="comment">/* @adbpg SharedStorage: wait for local flush and remote flush+replay */</span></span><br><span class="line">&#125;   SyncCommitLevel;</span><br></pre></td></tr></table></figure>
对于只读查询来说，只有3个基本：</li>
</ol>
<p><strong>local flush：</strong>master本地刷盘或者异步提交，这个都可能会造成standby落后比较多的数据。而且如果 master挂了，也存在丢失数据的风险。<br><strong>remote flush：</strong>standby wirte或者flush到本地磁盘。这个对于只读查询看到的数据没有区别，但是会比local flush要好很多，如果standby压力不大，能够及时的redo日志的话。write和flush的区别是，write也存在丢失数据的风险。<br><strong>remote apply：</strong>这个是最高级别，目前pg9.4没有，9.6才有。意思是 ，master必须等待standby redo完这些事务产生的日志才返回成功，这样基本上就做到了数据的实时查询。这种情况下一个有意思的事情是，可能会出现standby上先查询到新的数据，而master上查询不到。主要是因为事务在master上虽然已经提交了，但是事务还没有从活跃事务链表中删除，如果在这之前standby完成的redo，这standby会比master先看到数据。</p>
<h1 id="配置hot-standby"><a href="#配置hot-standby" class="headerlink" title="配置hot standby"></a>配置hot standby</h1><p>为pg集群创建一个hot standby步骤如下：</p>
<ol>
<li>修改master的postgres.conf配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wal_level &#x3D; hot_standby</span><br><span class="line">max_wal_senders &#x3D; 10</span><br><span class="line">synchronous_standby_names&#x3D;&#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li>修改master的pg_hba.conf：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local   replication     test                                trust</span><br><span class="line">host    replication     test        127.0.0.1&#x2F;32            trust</span><br></pre></td></tr></table></figure></li>
<li>重启master</li>
<li>pg_basebackup<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup -D .&#x2F;standby -R -x -P -p 35000 -U test</span><br></pre></td></tr></table></figure></li>
<li>修改standby的recovery.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">standby_mode &#x3D; &#39;on&#39;</span><br><span class="line">primary_conninfo &#x3D; &#39;user&#x3D;test port&#x3D;35000 sslmode&#x3D;disable sslcompression&#x3D;1&#39;</span><br></pre></td></tr></table></figure></li>
<li>启动standby即可。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/postgresql/" rel="tag"># postgresql</a>
              <a href="/tags/standby/" rel="tag"># standby</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/15/pg-%E5%A4%A7%E4%BC%9A-gauss-db-%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/" rel="prev" title="pg 大会--GaussDB 技术探索">
      <i class="fa fa-chevron-left"></i> pg 大会--GaussDB 技术探索
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/07/about/" rel="next" title="about">
      about <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#transaction-tracking"><span class="nav-number">2.</span> <span class="nav-text">transaction tracking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">基本流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#standby-state%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">standby state状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XLOG-RUNNING-XACTS"><span class="nav-number">2.3.</span> <span class="nav-text">XLOG_RUNNING_XACTS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hot-standby-snapshot%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.4.</span> <span class="nav-text">hot standby snapshot的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD"><span class="nav-number">2.5.</span> <span class="nav-text">事务可见性判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KnownAssignedXids"><span class="nav-number">2.6.</span> <span class="nav-text">KnownAssignedXids</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#standby%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.</span> <span class="nav-text">standby冲突解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%86%B2%E7%AA%81"><span class="nav-number">3.1.</span> <span class="nav-text">锁冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vacuum%E5%86%B2%E7%AA%81"><span class="nav-number">3.2.</span> <span class="nav-text">vacuum冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XLOG-STANDBY-LOCK"><span class="nav-number">3.3.</span> <span class="nav-text">XLOG_STANDBY_LOCK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pg-stat-database-conflicts"><span class="nav-number">3.4.</span> <span class="nav-text">pg_stat_database_conflicts</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hot-standby%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%96%B0%E9%B2%9C%E5%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">hot standby上的数据新鲜度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEhot-standby"><span class="nav-number">5.</span> <span class="nav-text">配置hot standby</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zisedeqing</p>
  <div class="site-description" itemprop="description">Postgresql 技术博客，欢迎交流</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:zisedeqing@163.com" title="E-Mail → mailto:zisedeqing@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zisedeqing</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数: <span id="busuanzi_value_site_uv"></span>
</div>
<!--
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数: <span id="busuanzi_value_site_uv"></span>
</div>

  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '5bNWe8x4EgbCqXVHlxSSScU2-gzGzoHsz',
      appKey     : 'TQiYOaDmW7IqsxCYmrvv1G1b',
      placeholder: "欢迎交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
