<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zisedeqing.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 相关代码12345678910111213141516171819202122src&#x2F;backend&#x2F;access&#x2F;aocs                    aocs_compaction.c                    aocsam.c                    aocssegfiles.c                &amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="Greenplum 列存原理分析">
<meta property="og:url" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="zisedeqing">
<meta property="og:description" content="1. 相关代码12345678910111213141516171819202122src&#x2F;backend&#x2F;access&#x2F;aocs                    aocs_compaction.c                    aocsam.c                    aocssegfiles.c                &amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/rownum.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block-header.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aocsseg_XXX.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aovisimap_XXX.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/global-deadlock.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/insert.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/update.png">
<meta property="article:published_time" content="2020-12-28T13:15:43.000Z">
<meta property="article:modified_time" content="2020-12-29T01:32:53.309Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="greenplum">
<meta property="article:tag" content="aocs">
<meta property="article:tag" content="列存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png">

<link rel="canonical" href="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Greenplum 列存原理分析 | zisedeqing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zisedeqing" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zisedeqing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zisedeqing">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Greenplum 列存原理分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-28 21:15:43" itemprop="dateCreated datePublished" datetime="2020-12-28T21:15:43+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-29 09:32:53" itemprop="dateModified" datetime="2020-12-29T09:32:53+08:00">2020-12-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/greenplum6-0/" itemprop="url" rel="index"><span itemprop="name">greenplum6.0</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/greenplum6-0/aocs/" itemprop="url" rel="index"><span itemprop="name">aocs</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-相关代码"><a href="#1-相关代码" class="headerlink" title="1. 相关代码"></a>1. 相关代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;backend&#x2F;access&#x2F;aocs</span><br><span class="line">                    aocs_compaction.c</span><br><span class="line">                    aocsam.c</span><br><span class="line">                    aocssegfiles.c</span><br><span class="line">                &#x2F;appendonly</span><br><span class="line">                    appendonlyam.c</span><br><span class="line">                    aomd.c</span><br><span class="line">                    aosegfiles.c</span><br><span class="line">                    appendonly_compaction.c</span><br><span class="line">                    appendonly_visimap.c</span><br><span class="line">                    appendonly_visimap_entry.c</span><br><span class="line">                    appendonly_visimap_store.c</span><br><span class="line">                    appendonly_visimap_udf.c</span><br><span class="line">                    appendonlyblockdirectory.c</span><br><span class="line">                    appendonlytid.c</span><br><span class="line">                    appendonlywriter.c</span><br><span class="line">src&#x2F;backend&#x2F;utils&#x2F;datumstream</span><br><span class="line">                    datumstream.c</span><br><span class="line">                    datumstreamblock.c</span><br><span class="line">src&#x2F;backend&#x2F;cdb&#x2F;</span><br><span class="line">                cdbbufferedappend.c</span><br><span class="line">                cdbbufferedread.c</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2-组织结构"><a href="#2-组织结构" class="headerlink" title="2. 组织结构"></a>2. 组织结构</h1><p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="aocs-组织结构图"></p>
<h2 id="2-1-segfile"><a href="#2-1-segfile" class="headerlink" title="2.1 segfile"></a>2.1 segfile</h2><ol>
<li>不同的列存储在不同的文件内，</li>
<li>一个列的物理文件最多只有128个</li>
<li>列文件以block为单位组织，压缩后的block大小不一，并且该文件没有文件头信息。</li>
<li>压缩之前的block大小也不是固定的，根据当前事务的写入量而定。</li>
<li>segfile size没有限制，只限制一个segfile最多存储的行数：2^40-1 (约10095亿)。并且默认情况下在存储到达90%时，会切换新的文件(具体细节查看SetSegnoForWrite函数) </li>
</ol>
<p>gp的segfile存在溢出bug，gp在insert to segfile时并不会检查rowcount是否超过2^40-1，所以如果再同一个事务内插入大量数据到一个将要满的segfile，就可能会导致文件溢出。而这个溢出操作并不会导致数据库报错，而是rownum &gt; 2^40-1的数据都会丢失。</p>
<h2 id="2-2-rownum"><a href="#2-2-rownum" class="headerlink" title="2.2 rownum"></a>2.2 rownum</h2><h3 id="2-2-1-为何引入rownum"><a href="#2-2-1-为何引入rownum" class="headerlink" title="2.2.1 为何引入rownum"></a>2.2.1 为何引入rownum</h3><p>对于heap表，pg使用tid表示tuple的物理位置，但是对于aocs表，由于压缩的原因，无法确定一个tuple在文件中的物理位置，所以gp引入了rownum表示tuple在文件中的逻辑位置。</p>
<ol>
<li>rownum 是递增的，但可能不连续，不连续的原因是insert时为了效率每次都是生成一批rownum</li>
<li>每个tuple都唯一的对应一个rownum，与tid一样</li>
<li>不同的segfile的tuple rownum单独计算</li>
</ol>
<p>所以在同一个block内，rownum一定是连续的</p>
<ol start="4">
<li>如何使用rownum找到对应的tuple</li>
</ol>
<p>首先block header记录的当前block的第一个rownum和rowcount，所以只需要遍历整个文件，如果rownum 在[firstrownum, firstrownum+rowcount]范围内，则找到tuple对应的 block，遍历block即可。</p>
<h3 id="2-2-2-aocs的tuple-id"><a href="#2-2-2-aocs的tuple-id" class="headerlink" title="2.2.2 aocs的tuple id"></a>2.2.2 aocs的tuple id</h3><p>gp使用AOTupleId 表示tuple id(与pg的tid对应，heap表使用ItemPointer表示tid)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AOTupleId</span><br><span class="line">&#123;</span><br><span class="line">	uint16      bytes_0_1;</span><br><span class="line">	uint16		bytes_2_3;</span><br><span class="line">	uint16		bytes_4_5;</span><br><span class="line"></span><br><span class="line">&#125; AOTupleId;</span><br></pre></td></tr></table></figure>
<p>最左7位是segment no，所以最多只有128文件<br>最右的第16位是保留位，一定是1<br>剩下的40位元组在文件的位置标记，即rownum。<br>如下图所示：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/rownum.png" alt="rownum"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>为什么第33位要标记为1？</strong></li>
</ul>
<p>主要原因是AOTupleId在一些地方如executor等会转换成行存的Itempointer，在代码中有很多ItemPointerIsValid的判断，为了简单gp把第33位标记为1.<br>实际上要过ItemPointerIsValid的判断，只需要把最后16位的任意一位标记为1即可，不确定为什么选择最后16位的第一个位。</p>
<h2 id="2-3-block"><a href="#2-3-block" class="headerlink" title="2.3 block"></a>2.3 block</h2><p>对于列存的block，每个block有2个header，一个是block header，另一个是datum header。其中block header是不会压缩的，datum header会压缩。</p>
<h3 id="2-3-1-header"><a href="#2-3-1-header" class="headerlink" title="2.3.1 header"></a>2.3.1 header</h3><ul>
<li><input checked disabled type="checkbox"> <strong>block header</strong></li>
</ul>
<p>block header size： 8bytes + 8bytes + 4 bytes = 20 bytes<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block-header.png" alt="block header"><br>类型：</p>
<ol>
<li>AoHeaderKind_SmallContent  一般的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AOSmallContentHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      uint32            smallcontent_bytes_0_3;</span><br><span class="line">      uint32            smallcontent_bytes_4_7;</span><br><span class="line">&#125;AOSmallContentHeader</span><br></pre></td></tr></table></figure></li>
<li>AoHeaderKind_LargeContent 超长字段，一个block存不下，分成多个block存储</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AOLargeContentHeader</span><br><span class="line">&#123;</span><br><span class="line">    uint32            largecontent_bytes_0_3;</span><br><span class="line">    uint32            largecontent_bytes_4_7;</span><br><span class="line">&#125;AOLargeContentHeader</span><br></pre></td></tr></table></figure>
<p>如果一个字段长度超长，则会被分割成多个block存储，方式是：<br>large block|small block|…|small block</p>
<ol start="3">
<li>AoHeaderKind_NonBulkDenseContent </li>
</ol>
<p>column compress type = rle_type<br>column compress level = 1 &amp;&amp;<br>rowcount &gt; 16383</p>
<ol start="4">
<li>AoHeaderKind_BulkDenseContent</li>
</ol>
<p>column compress type = rle_type<br>column compress level &gt; 1 &amp;&amp;<br>rowcount &gt; 16383<br><strong>未看到哪种情况会走这个</strong></p>
<p>[x] <strong>datum header</strong><br>类型：</p>
<ol>
<li>DatumStreamVersion_Original</li>
</ol>
<p>无压缩或者zlib压缩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Datum Stream Block (Original).</span></span><br><span class="line"><span class="comment"> * 16 bytes header.  Followed by data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumStreamBlock_Orig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	int16		version;		<span class="comment">/* version number */</span></span><br><span class="line">	int16		flags;			<span class="comment">/* some flags */</span></span><br><span class="line">	int16		ndatum;			<span class="comment">/* number of datum, including null */</span></span><br><span class="line">	int16		unused;			<span class="comment">/* unused */</span></span><br><span class="line">	int32		nullsz;			<span class="comment">/* size nullbitmaps */</span></span><br><span class="line">	int32		sz;				<span class="comment">/* logical data size, not including header,</span></span><br><span class="line"><span class="comment">								 * nullbitmap, and padding */</span></span><br><span class="line">&#125;	DatumStreamBlock_Orig;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>DatumStreamVersion_Dense</li>
</ol>
<p>目前版本无该类型的block，猜测是用于quicklz压缩的</p>
<ol start="3">
<li>DatumStreamVersion_Dense_Enhanced</li>
</ol>
<p>压缩类型为: RLE_TYPE<br>DatumStreamBlock_Dense<br>DatumStreamBlock_Rle_Extension<br>DatumStreamBlock_Delta_Extension</p>
<h3 id="2-3-2-block-size"><a href="#2-3-2-block-size" class="headerlink" title="2.3.2 block size"></a>2.3.2 block size</h3><p>列存block size 范围：[8KB, 2MB]，压缩之前的size<br>默认size是：32KB<br>真实的block size受限于用户建表时定义的blocksize，如果没有指定blocksize，则使用默认的blocksize。<br>还有一个参数会影响block size，就是gp列存限定了一个block最多可以存多少个value，如果超过这个值，即使没有达到block size限制还是会写入到另外的block内的。</p>
<ol>
<li>DatumStreamVersion_Original</li>
</ol>
<p>最多16383行, 即small content header row count最大值：2^14 - 1</p>
<ol start="2">
<li>DatumStreamVersion_Dense/DatumStreamVersion_Dense_Enhanced</li>
</ol>
<p>最多2^30 -1行, 即noblukdense header row count最大值</p>
<h3 id="2-3-3-null-bitmap"><a href="#2-3-3-null-bitmap" class="headerlink" title="2.3.3 null bitmap"></a>2.3.3 null bitmap</h3><p>用来存储null值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumStreamBitMapWrite</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	uint8	   *buffer;</span><br><span class="line">	int32		bufferSize;</span><br><span class="line"></span><br><span class="line">	uint8		byteBit;</span><br><span class="line">	uint8	   *bytePointer;</span><br><span class="line">	int32		bitOnCount;</span><br><span class="line">	int32		bitCount;</span><br><span class="line">&#125;	DatumStreamBitMapWrite;</span><br></pre></td></tr></table></figure>

<h1 id="3-辅助元信息表"><a href="#3-辅助元信息表" class="headerlink" title="3. 辅助元信息表"></a>3. 辅助元信息表</h1><h2 id="3-1-库级别的meta表"><a href="#3-1-库级别的meta表" class="headerlink" title="3.1 库级别的meta表"></a>3.1 库级别的meta表</h2><p>pg_appendonly gp原有的，记录所有的appendonly表<br>gp_fastsequence rownum使用的sequence，segment上的有用</p>
<h2 id="3-2-表级别的meta表"><a href="#3-2-表级别的meta表" class="headerlink" title="3.2 表级别的meta表"></a>3.2 表级别的meta表</h2><p>下面的meta表是对于每个ao表都有，如果表是分区表，则每个自分区也都会有下面这些meta表。</p>
<h3 id="3-2-1-查询方法"><a href="#3-2-1-查询方法" class="headerlink" title="3.2.1 查询方法"></a>3.2.1 查询方法</h3><p>SELECT gp_segment_id, * from gp_dist_random(‘pg_aoseg.pg_aoblkdir_17684’)<br>注意使用utility直接登录segment查询是不行的，估计是可见性问题吧</p>
<h3 id="3-2-2-pg-aocsseg-XXX"><a href="#3-2-2-pg-aocsseg-XXX" class="headerlink" title="3.2.2 pg_aocsseg_XXX"></a>3.2.2 pg_aocsseg_XXX</h3><p>记录segfile 相关信息，包含元组数量、文件长度、修改次数等。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>文件号，表示第几个文件。对应于真实的文件是:</td>
</tr>
<tr>
<td>relfilenode.segno+（column_number - 1）* 128</td>
<td></td>
<td></td>
</tr>
<tr>
<td>比如relfilenode=451012的第二列的segno=2的文件名是：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>451012.130</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tupcount</td>
<td>bigint</td>
<td>元组数量，包含已经删除的和更新的。如果这个值与select count(*)差距比较大的话，就说明垃圾数据较多，需要做vacuum</td>
</tr>
<tr>
<td>varblockcount</td>
<td>bigint</td>
<td></td>
</tr>
<tr>
<td>vpinfo</td>
<td>bytea</td>
<td>记录文件长度，包含真实的eof和未压缩后的eof</td>
</tr>
<tr>
<td>modcount</td>
<td>bigint</td>
<td>文件修改次数</td>
</tr>
<tr>
<td>state</td>
<td>smallint</td>
<td>文件状态：USECURRENT/DEFAULT/AWAITING_DROP</td>
</tr>
</tbody></table>
<p>一个例子：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aocsseg_XXX.png" alt="pg_aocsseg_XXX"></p>
<h3 id="3-2-3-pg-aovisimap-XXX"><a href="#3-2-3-pg-aovisimap-XXX" class="headerlink" title="3.2.3 pg_aovisimap_XXX"></a>3.2.3 pg_aovisimap_XXX</h3><p>记录segfile里面的元组可见性信息，主要作用于update/delete，对于rollback导致的不可见是由pg_aocsseg_xxx里面记录的文件长度保证的。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>segfile number</td>
</tr>
<tr>
<td>first_row_no</td>
<td>bigint</td>
<td>当前范围内的第一个row num，从0开始，每个元组记录32768个元组可见性信息。</td>
</tr>
<tr>
<td>visimap</td>
<td>bit varying</td>
<td>记录元组可见性的bit map</td>
</tr>
</tbody></table>
<p>例子：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aovisimap_XXX.png" alt="pg_aovisimap_XXX"></p>
<p>如何判断一个rownum是否在当前visiMapEntry内：<br>bitoffset = rownum - first_row_no<br>(rownum &gt;= first_row_no &amp;&amp; rownum &lt; first_row_no + 32768) &amp;&amp;  (visimap &amp; (1&lt;&lt;bitoffset) != 0) == true ?</p>
<h3 id="3-2-4-pg-aoblkdir-XXX"><a href="#3-2-4-pg-aoblkdir-XXX" class="headerlink" title="3.2.4 pg_aoblkdir_XXX"></a>3.2.4 pg_aoblkdir_XXX</h3><p>块字典meta表，用于记录block位置信息。创建表的时候，默认不创建该表，在创建表的第一个index时，会创建该meta表。由于ao表的AOTupleId只记录的tuple的逻辑位置信息，不像heap的tid记录的是物理位置信息，在使用index scan时，无法通过AOTupleId直接的找到tuple，所以gp添加了pg_aoblkdir_XXX表，记录block的物理位置信息，来加上index scan tuple的fetch。<br>该系统表上以一个索引，索引列是(segno, columngroup_no, first_row_no)。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>segfile number</td>
</tr>
<tr>
<td>columngroup_no</td>
<td>integer</td>
<td>column number</td>
</tr>
<tr>
<td>first_row_no</td>
<td>bigint</td>
<td>该行覆盖的第一个tuple的rownum</td>
</tr>
<tr>
<td>minipage</td>
<td>bit varying</td>
<td>minEntry的数组，每个entry覆盖多个block</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MinipageEntry</span><br><span class="line">&#123;</span><br><span class="line">	int64 firstRowNum;   &#x2F;&#x2F; 当前entry覆盖的第一个tuple的rownum</span><br><span class="line">	int64 fileOffset;    &#x2F;&#x2F; 当前entry 覆盖的第一个block在文件中的偏移，该偏移是开始位置的偏移</span><br><span class="line">	int64 rowCount;      &#x2F;&#x2F; 当前entry覆盖的所有block的tuple个数 </span><br><span class="line">  										 &#x2F;&#x2F; (可能会比实际的个数要大，因为有些情况是计算出来的)</span><br><span class="line">&#125; MinipageEntry;</span><br><span class="line"></span><br><span class="line">typedef struct Minipage</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Total length. Must be the first. *&#x2F;</span><br><span class="line">	int32 _len;</span><br><span class="line">	int32 version;</span><br><span class="line">	uint32 nEntry;</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Varlena array *&#x2F;</span><br><span class="line">	MinipageEntry entry[1];</span><br><span class="line">&#125; Minipage;</span><br></pre></td></tr></table></figure>
<p>默认pg_aoblkdir_XXX的一行可以存储161(NUM_MINIPAGE_ENTRIES)个MinipageEntry信息， 每个MinipageEntry记录一个block的信息，但是为了提高性能，gp也提供如下方法来修改一个entry记录的block数量还有一行记录的entry数量：</p>
<ol>
<li>gp_blockdirectory_minipage_size</li>
</ol>
<p>一行记录存储的MinipageEntry数量, 取值范围是(1 .. 161)</p>
<ol start="2">
<li>gp_blockdirectory_entry_min_range</li>
</ol>
<p>控制一个MinipageEntry 记录的数据范围，取值范围（0, INT_MAX）.<br>计算方法：<br>current_fileOffset - last MinipageEntry.fileOffset &lt; gp_blockdirectory_entry_min_range，则跳过当前block，否则把当前block的相关信息记录到新的MinipageEntry。current_fileOffset - last MinipageEntry.fileOffset 表示的就是last MinipageEntry所能覆盖的范围。<br>gp_blockdirectory_entry_min_range参数会导致MinipageEntry的覆盖范围超过一个block，但是不会小于一个block。<br>pg_aoblkdir_XXX的维护：</p>
<ol>
<li>更新<ol>
<li>insert new tuple时，包含update</li>
<li>alter table add column时</li>
<li>build index时，创建新的索引的时候，在scan时会更新pg_aoblkdir_XXX</li>
</ol>
</li>
<li>查询 – index scan， 如何使用pg_aoblkdir_XXX快速定位tuple</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AppendOnlyBlockDirectoryEntry</span><br><span class="line">&#123;</span><br><span class="line">	struct range</span><br><span class="line">	&#123;</span><br><span class="line">		int64		fileOffset;     &#x2F;&#x2F; current MinipageEntry.fileOffset</span><br><span class="line">		int64		firstRowNum;    &#x2F;&#x2F; current MinipageEntry.firstRowNum</span><br><span class="line"></span><br><span class="line">		int64		afterFileOffset;  &#x2F;&#x2F; next MinipageEntry.fileOffset</span><br><span class="line">		int64		lastRowNum;       &#x2F;&#x2F; current MinipageEntry.firstRowNum + current MinipageEntry.rowCount - 1</span><br><span class="line">	&#125; range;</span><br><span class="line">&#125; AppendOnlyBlockDirectoryEntry;</span><br></pre></td></tr></table></figure>
<p>根据AOTupleId，算出segfile number和rownum，使用pg_aoblkdir_XXX上的索引，进行索引扫描（条件：segno=segfile number and columngroup_no = column_no and first_row_no &lt;= rownum）快速定位到 AOTupleId 所在的MiniPage。然后通过二分查找在MiniPage中查找rownum所在的block。找到block后，就可以通过fileseek直接读取block，然后遍历block即可找到对应的tuple。</p>
<h1 id="4-insert-update-delete"><a href="#4-insert-update-delete" class="headerlink" title="4. insert/update/delete"></a>4. insert/update/delete</h1><h2 id="4-1-insert"><a href="#4-1-insert" class="headerlink" title="4.1 insert"></a>4.1 insert</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecInsert&#x2F;CopyFrom</span><br><span class="line">	aocs_insert_init</span><br><span class="line">  aocs_insert_values</span><br><span class="line">  </span><br><span class="line">ExecEndPlan&#x2F;CopyFrom</span><br><span class="line">	aocs_insert_finish</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_init</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化AOCSInsertDesc</span><br><span class="line">open DatumStreams</span><br><span class="line">从gp_fastsequence获取rownum range</span><br><span class="line">初始化fist rownum</span><br><span class="line">初始化AppendOnlyBlockDirectory</span><br></pre></td></tr></table></figure></li>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_values</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for each columns</span><br><span class="line">do</span><br><span class="line">	尝试把value存入当前block</span><br><span class="line">  if failed</span><br><span class="line">  	把当前block写入buffer，并清空当前block</span><br><span class="line">    更新blockDirectory系统表</span><br><span class="line">  	再次尝试把value写入当前block</span><br><span class="line">    if failed</span><br><span class="line"> 			把value分割，写入不同的block(lob，large object)</span><br><span class="line">  		更新blockDirectory系统表</span><br><span class="line">done</span><br><span class="line">set AOTupleId</span><br><span class="line">如 rownum 使用完了，从新从gp_fastsequence获取一批rownum(100)</span><br></pre></td></tr></table></figure>
有几点需要注意的是：</li>
</ul>
<ol>
<li>如果压缩类型是rle_type，则使用lob存储时，不会进行压缩</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_finish</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for each columns</span><br><span class="line">do</span><br><span class="line">	write block to buffer</span><br><span class="line">  update block directory catalog</span><br><span class="line">  close file</span><br><span class="line">  	flush buffer content to disk</span><br><span class="line">    sync content to mirror</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">update aocs file segment information</span><br><span class="line">some cleanup job</span><br></pre></td></tr></table></figure>
<h2 id="4-2-delete"><a href="#4-2-delete" class="headerlink" title="4.2 delete"></a>4.2 delete</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecDelete</span><br><span class="line">	aocs_delete_init</span><br><span class="line">  aocs_delete</span><br><span class="line">  </span><br><span class="line"> ExecEndPlan</span><br><span class="line"> 	aocs_delete_finish</span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_delete_init</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化AOCSDeleteDesc</span><br><span class="line">初始化visibilityMap</span><br><span class="line">初始化visibilityMapDelete</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>aocs_delete</strong><br>比较简单就是把visibilityMap上对应的位置标记为1<br>主要工作在AppendOnlyVisimapDelete_Hide里面完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if tuple不在current_Visimap_Entry内</span><br><span class="line">	if current_Visimap_Entry is dirty</span><br><span class="line">  	把current_Visimap_Entry刷入外存(使用work file组织)</span><br><span class="line">  查找tuple对应的visimap entry并加装到current_Visimap_Entry</span><br><span class="line">标记current_Visimap_Entry 对应的bit为1，并设置为dirty</span><br></pre></td></tr></table></figure>
<p>对于pg_aovisimap_XXX 系统表的修改，gp这里做了一个特殊处理，原有系统表的修改是通过shared_buffer来做的，没改一次要修改一次shared_buffer并记录xlog。这里gp对于pg_aovisimap_XXX 的修改做了优化，把同一条语句内多次修改pg_aovisimap_XXX 的操作合并成了，这样可以减少pg_aovisimap_XXX 的更新次数已经xlog量。合并的方式是：对应pg_aovisimap_XXX 的修改先记录到内存，如果内存放不下，则写入到work file内，在最后语句结束的是在把内存和work file内的修改更新到pg_aovisimap_XXX 上。<br>这样做的出发点：</p>
<ol>
<li>减少pg_aovisimap_XXX由于更新导致的过度膨胀</li>
<li>减少xlog，可以提高mirror同步效率</li>
</ol>
</li>
<li><p><strong>aocs_delete_finish</strong></p>
</li>
</ul>
<p>主要是把内存中的visimap entry 和work file内的entry 合并然后更新到pg_aovisimap_XXX</p>
<h2 id="4-3-update"><a href="#4-3-update" class="headerlink" title="4.3 update"></a>4.3 update</h2><p>update操作实际就是 delete + insert，代码上也基本是这样实现的，没啥好说的。<br>有一点是，虽然是列存，但是update的时候还是按行来做的，即使我们只update某一列，实际上与行存一样，aocs也是把整个行标记为delete，然后insert新的行。</p>
<h2 id="4-4-copy-from"><a href="#4-4-copy-from" class="headerlink" title="4.4 copy from"></a>4.4 copy from</h2><p>与insert 类似</p>
<h2 id="4-5-iud并发控制"><a href="#4-5-iud并发控制" class="headerlink" title="4.5 iud并发控制"></a>4.5 iud并发控制</h2><ul>
<li><input checked disabled type="checkbox"> <strong>update/delete并发控制</strong></li>
</ul>
<p>update/delete并发控制比较简单，在执行时加表的ExclusiveLock, 把update/delete/ select for update操作串行化。<br>这样做的目的主要是防止死锁，由于gp没有全局的死锁检测机制，所以弱化update并发来解决死锁问题。<br>目前gp死锁检测处理不了的情况：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/global-deadlock.png" alt="global-deadlock"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert与insert的并发控制</strong></li>
</ul>
<p>对于同一个表的insert是可以并发执行的，由于列存与pg heap表不同，gp针对列存表单独实现了一个比较简单粗暴的并发控制机制：对于insert操作，每个insert进程处理不同的segfile，即insert 进程直接不会有冲突，所以也不需要加锁等控制。简单来说有2点：</p>
<ol>
<li>对于列存文件的修改，每个insert进程修改不同的segfile</li>
</ol>
<p>在insert之前，gp会为insert进程分配当前进程插入的segfile，不同的insert 进程插入不同的segfile，处理流程可以看一下SetSegnoForWrite函数的实现。</p>
<ol start="2">
<li>对应meta表的修改，走pg heap 表，使用pg原有的并发控制机制</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert与update/delete的并发控制</strong></li>
</ul>
<p>由于update/delete需要加ExclusiveLock锁，导致insert与update/delete也无法并行执行</p>
<h1 id="5-scan"><a href="#5-scan" class="headerlink" title="5. scan"></a>5. scan</h1><h2 id="5-1-table-scan"><a href="#5-1-table-scan" class="headerlink" title="5.1 table scan"></a>5.1 table scan</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aocs_beginscan</span><br><span class="line">while !done</span><br><span class="line">	aocs_getnext</span><br><span class="line">aocs_endscan</span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_beginscan</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resourceowner table refcount+1</span><br><span class="line">GetAppendOnlyEntry</span><br><span class="line">从pg_aoseg_xxx表查询所有的segfile信息</span><br><span class="line">create AOCSScanDesc</span><br><span class="line">	aocs_initscan</span><br><span class="line">  	open_ds_read</span><br><span class="line">  AppendOnlyVisimap_Init</span><br></pre></td></tr></table></figure>
关于scan时的snapshot：</li>
</ul>
<ol>
<li>current_snapshot， 正常查询的snapshot，scan之前生成</li>
</ol>
<p>tabledata_snapshot: current_snapshot<br>metadata_snapshot: current_snapshot</p>
<ol start="2">
<li>SnapshotAny，开启gp_select_invisible后使用，用于查询历史数据。</li>
</ol>
<p>tabledata_snapshot: SnapshotAny<br>aocs表tuple上是没有事务信息的，这个snapshot主要是用来配合pg_visimap_xxx系统表的<br>metadata_snapshot: current_snapshot</p>
<ul>
<li><p><strong>aocs_endscan</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resourceowner table refcount-1</span><br><span class="line">destory AOCSScanDesc</span><br><span class="line">	close_cur_scan_seg</span><br><span class="line">  close_ds_read</span><br><span class="line">  AppendOnlyVisimap_Finish</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>aocs_getnext</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">READ_NEXT:</span><br><span class="line">	<span class="keyword">if</span> necessary, open next segfile;</span><br><span class="line">    <span class="keyword">if</span> (No more seg)</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  	foreach_columns</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="keyword">if</span> (scan-&gt;proj[i] == <span class="literal">false</span>)</span><br><span class="line">    		<span class="comment">// 查询没有使用到该column，skip read</span></span><br><span class="line">    		<span class="keyword">continue</span>;</span><br><span class="line">      </span><br><span class="line">   		<span class="comment">//当前block的current_tuple 后移，类似于jdbc ResultSet.next</span></span><br><span class="line">    	datumstreamread_advance;</span><br><span class="line">    	<span class="keyword">if</span> (no tuple)</span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="comment">// read next block</span></span><br><span class="line">            datumstreamread_block;</span><br><span class="line">            <span class="keyword">if</span> (end of file)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> READ_NEXT;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> necessary, insert block directory meta entry;</span><br><span class="line">            datumstreamread_advance;</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get current column value</span></span><br><span class="line">        datumstreamread_get</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> AOTupleId</span><br><span class="line">    数据可见性判断，如果不可见 <span class="keyword">goto</span> READ_NEXT;</span><br><span class="line">    save current tuple <span class="keyword">and</span> AOTupleId;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>对于查询未涉及的column，read时自动跳过，减少io</li>
<li>数据可见性判断<ul>
<li>如果tabledata_snapshot是SnapshotAny，则跳过可见性判断</li>
<li>否则，通过visimap判断tuple是否已经被删除</li>
</ul>
</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_getnext_comp</strong></li>
</ul>
<p>开启向量化后，aocs scan接口。与aocs_getnext的不同之处在于：</p>
<ol>
<li>aocs_getnext每次读取一个tuple，然后就返回，而aocs_getnext_comp是每次读取一批tuple。</li>
<li>对于向量化，会有一些谓词下推，所以aocs_getnext_comp会做一些filter<h2 id="5-2-index-scan"><a href="#5-2-index-scan" class="headerlink" title="5.2 index scan"></a>5.2 index scan</h2>aocs上的索引扫描<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BitmapAppendOnlyScanNext</span><br><span class="line">	aocs_fetch_init</span><br><span class="line">  aocs_fetch</span><br><span class="line">	aocs_fetch_finish</span><br></pre></td></tr></table></figure>
aocs_fetch：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foreach_columns</span><br><span class="line">&#123;</span><br><span class="line">	从BlockDirectoryEntry找到tuple所在block</span><br><span class="line">    从block中读取tuple</span><br><span class="line">    判断tuple可见性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可优化的地方：</p>
<ol>
<li>先做可见性判断在读block</li>
</ol>
<p>目前做可见性判断时是先把tuple所在block 从disk读到内存，然后在判断可见性。实际上aocs的可见性信息是记录在pg_aovisimap表里面的，可以先判断可见性，再读block，这样如果不可见可以减少不必须的io。</p>
<ol start="2">
<li>第一列通过可见性判断后，后面列可以跳过可见性判断</li>
</ol>
<p>rownum是tuple的唯一标识，如果tuple的第一列通过了可见性判断，则后面所有的列也是可见的，因此是不需要再做可见性判断的</p>
<h2 id="5-3-header-scan"><a href="#5-3-header-scan" class="headerlink" title="5.3 header scan"></a>5.3 header scan</h2><p>alter table add column 是调用，粗略看了一下代码，主要是用来辅助创建新的column对应的segfile的。header scan实际上扫描的时候只是把block读取出来，并不会把block解压，主要是使用block上的header信息。<br>有两点：</p>
<ol>
<li>ao表 添加新的column时，必须指定default value</li>
<li>新segfile与之前column的segfile在结构完基本一样，比如每个block记录多少个tuple等<h2 id="5-4-tid-scan"><a href="#5-4-tid-scan" class="headerlink" title="5.4 tid scan"></a>5.4 tid scan</h2>ao表没有tid scan，只有heap表有<h2 id="5-5-range-scan"><a href="#5-5-range-scan" class="headerlink" title="5.5 range scan"></a>5.5 range scan</h2>主要是做compaction 时使用。与 table scan类似，不同之处是每次只扫描指定的几个segfile，而不是扫描所有的segfile。<h1 id="6-事务ACID"><a href="#6-事务ACID" class="headerlink" title="6. 事务ACID"></a>6. 事务ACID</h1>aocs实现了类似heap的mvcc，并且支持完整的事务ACID。aocs表数据分为两种：一是用户数据，二是meta数据。用户数据存储在segfile中，只存储数据，不存储任何事务信息(与heap表不同)，commit之前一定会flush到磁盘；meta数据存储在heap表中，通过分布式事务保证。<br>aocs的实现事务的meta表有2个 pg_aocsseg_xxx和pg_aovisimap_xxx，其中pg_aocsseg_xxx记录数据文件的逻辑长度(即当前事务可以看到的长度)；pg_aovisimap_xxx记录delete tuple，即哪些tuple被删除了。</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert</strong></li>
</ul>
<p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/insert.png" alt="insert"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>update</strong></li>
</ul>
<p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/update.png" alt="update"></p>
<h1 id="7-aocs-compaction"><a href="#7-aocs-compaction" class="headerlink" title="7. aocs compaction"></a>7. aocs compaction</h1><p>类似于heap表的vacuum，用来清理 delete的tuple或者rollback后残留的tuple。<br>gp对vacuum操作进行了改造，目的是为了适应分布式系统，把原来pg的一个vacuum分成了几个阶段，每个阶段使用一个分布式事务。<br>对于ao表分为4个阶段：</p>
<ol>
<li>prepare phase</li>
</ol>
<p>truncate unnecessary blocks after the logical EOF</p>
<ol start="2">
<li>compaction phase</li>
<li>drop phase</li>
</ol>
<p>删除compaction phase的segfile</p>
<ol start="4">
<li>cleanup phase</li>
</ol>
<p>does normal heap vacuum on auxiliary relations (toast, aoseg, block directory, visimap,) as well as updating stats info in catalog</p>
<p>compaction主要有两种操作：</p>
<ol>
<li>AOCSCompaction_DropSegmentFile</li>
</ol>
<p>删掉AOSEG_STATE_AWAITING_DROP状态的segfile。在vacuum的drop phase做。</p>
<ol start="2">
<li>AOCSTruncateToEOF</li>
</ol>
<p>在不满足compaction条件时，做truncate，这操作主要是清理最近rollback的事务残留在文件尾部的tuple。</p>
<ol start="3">
<li>AOCSSegmentFileFullCompaction</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> 触发sql</li>
</ul>
<p>vacuum<br>vacuum full</p>
<ul>
<li><input checked disabled type="checkbox"> 哪些情况会做</li>
</ul>
<p>AppendOnlyCompaction_ShouldCompact</p>
<ol>
<li>vacuum full 且有delete</li>
<li>删除的tuple所占比例大于gp_appendonly_compaction_threshold</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> 如何做compaction</li>
</ul>
<p>compaction的做法比较简单：</p>
<ol>
<li>选择一个segfile做compaction，然后再选择一个segfile作为insert segfile。</li>
<li>遍历compaction segfile的每个tuple，如果可见(snapshot为SnapshotNow)则插入到insert segfile，如果不可见则删除。</li>
<li>set compaction segfile为AOSEG_STATE_AWAITING_DROP</li>
<li>delete visimap和block directory 中对应segno的数据</li>
</ol>
<p>insert segfile的选择：<br>选择tuple数最小的segfile或者当前vacuum事务正在使用的segfile作为insert segfile。</p>
<ul>
<li><input checked disabled type="checkbox"> 相关guc参数<table>
<thead>
<tr>
<th>参数名</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>gp_appendonly_compaction</td>
<td>是否开启compaction，如果是off，则vacuum时只需TruncateToEOF</td>
</tr>
<tr>
<td>gp_appendonly_compaction_threshold</td>
<td>compaction 的阈值</td>
</tr>
<tr>
<td>Debug_appendonly_print_compaction</td>
<td>输出debug信息</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="8">
<li>aocs表的一些限制</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>不支持unique index</strong></li>
</ul>
<p>不支持的原因是在检查到冲突的tuple后，无法判断该tuple的事务信息。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/greenplum/" rel="tag"># greenplum</a>
              <a href="/tags/aocs/" rel="tag"># aocs</a>
              <a href="/tags/%E5%88%97%E5%AD%98/" rel="tag"># 列存</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/28/Greenplum-6-0-HA/" rel="prev" title="Greenplum 6.0 HA">
      <i class="fa fa-chevron-left"></i> Greenplum 6.0 HA
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/28/Greenplum-shared-snapshot/" rel="next" title="Greenplum shared snapshot">
      Greenplum shared snapshot <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">1. 相关代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">2. 组织结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-segfile"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 segfile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-rownum"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 rownum</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5rownum"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 为何引入rownum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-aocs%E7%9A%84tuple-id"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 aocs的tuple id</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-block"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 block</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-header"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 header</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-block-size"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 block size</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-null-bitmap"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 null bitmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BE%85%E5%8A%A9%E5%85%83%E4%BF%A1%E6%81%AF%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">3. 辅助元信息表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%BA%93%E7%BA%A7%E5%88%AB%E7%9A%84meta%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 库级别的meta表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84meta%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 表级别的meta表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 查询方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-pg-aocsseg-XXX"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 pg_aocsseg_XXX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-pg-aovisimap-XXX"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 pg_aovisimap_XXX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-pg-aoblkdir-XXX"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 pg_aoblkdir_XXX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-insert-update-delete"><span class="nav-number">4.</span> <span class="nav-text">4. insert&#x2F;update&#x2F;delete</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-insert"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 insert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-delete"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-update"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 update</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-copy-from"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 copy from</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-iud%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 iud并发控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-scan"><span class="nav-number">5.</span> <span class="nav-text">5. scan</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-table-scan"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 table scan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-index-scan"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 index scan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-header-scan"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 header scan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-tid-scan"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 tid scan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-range-scan"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 range scan</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E4%BA%8B%E5%8A%A1ACID"><span class="nav-number">6.</span> <span class="nav-text">6. 事务ACID</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-aocs-compaction"><span class="nav-number">7.</span> <span class="nav-text">7. aocs compaction</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
