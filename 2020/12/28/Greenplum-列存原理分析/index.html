<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Greenplum 列存原理分析 | zisedeqing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. 相关代码12345678910111213141516171819202122src&#x2F;backend&#x2F;access&#x2F;aocs                    aocs_compaction.c                    aocsam.c                    aocssegfiles.c                &amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="Greenplum 列存原理分析">
<meta property="og:url" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="zisedeqing">
<meta property="og:description" content="1. 相关代码12345678910111213141516171819202122src&#x2F;backend&#x2F;access&#x2F;aocs                    aocs_compaction.c                    aocsam.c                    aocssegfiles.c                &amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/rownum.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block-header.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aocsseg_XXX.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aovisimap_XXX.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/global-deadlock.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/insert.png">
<meta property="og:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/update.png">
<meta property="article:published_time" content="2020-12-28T13:15:43.000Z">
<meta property="article:modified_time" content="2020-12-28T13:31:09.492Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="greenplum">
<meta property="article:tag" content="aocs">
<meta property="article:tag" content="列存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png">
  
    <link rel="alternate" href="/atom.xml" title="zisedeqing" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zisedeqing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zisedeqing.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Greenplum-列存原理分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2020-12-28T13:15:43.000Z" itemprop="datePublished">2020-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/greenplum/">greenplum</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Greenplum 列存原理分析
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-相关代码"><a href="#1-相关代码" class="headerlink" title="1. 相关代码"></a>1. 相关代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;backend&#x2F;access&#x2F;aocs</span><br><span class="line">                    aocs_compaction.c</span><br><span class="line">                    aocsam.c</span><br><span class="line">                    aocssegfiles.c</span><br><span class="line">                &#x2F;appendonly</span><br><span class="line">                    appendonlyam.c</span><br><span class="line">                    aomd.c</span><br><span class="line">                    aosegfiles.c</span><br><span class="line">                    appendonly_compaction.c</span><br><span class="line">                    appendonly_visimap.c</span><br><span class="line">                    appendonly_visimap_entry.c</span><br><span class="line">                    appendonly_visimap_store.c</span><br><span class="line">                    appendonly_visimap_udf.c</span><br><span class="line">                    appendonlyblockdirectory.c</span><br><span class="line">                    appendonlytid.c</span><br><span class="line">                    appendonlywriter.c</span><br><span class="line">src&#x2F;backend&#x2F;utils&#x2F;datumstream</span><br><span class="line">                    datumstream.c</span><br><span class="line">                    datumstreamblock.c</span><br><span class="line">src&#x2F;backend&#x2F;cdb&#x2F;</span><br><span class="line">                cdbbufferedappend.c</span><br><span class="line">                cdbbufferedread.c</span><br></pre></td></tr></table></figure>
<h1 id="2-组织结构"><a href="#2-组织结构" class="headerlink" title="2. 组织结构"></a>2. 组织结构</h1><p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/aocs-%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="aocs-组织结构图"></p>
<h2 id="2-1-segfile"><a href="#2-1-segfile" class="headerlink" title="2.1 segfile"></a>2.1 segfile</h2><ol>
<li>不同的列存储在不同的文件内，</li>
<li>一个列的物理文件最多只有128个</li>
<li>列文件以block为单位组织，压缩后的block大小不一，并且该文件没有文件头信息。</li>
<li>压缩之前的block大小也不是固定的，根据当前事务的写入量而定。</li>
<li>segfile size没有限制，只限制一个segfile最多存储的行数：2^40-1 (约10095亿)。并且默认情况下在存储到达90%时，会切换新的文件(具体细节查看SetSegnoForWrite函数) </li>
</ol>
<p>gp的segfile存在溢出bug，gp在insert to segfile时并不会检查rowcount是否超过2^40-1，所以如果再同一个事务内插入大量数据到一个将要满的segfile，就可能会导致文件溢出。而这个溢出操作并不会导致数据库报错，而是rownum &gt; 2^40-1的数据都会丢失。</p>
<h2 id="2-2-rownum"><a href="#2-2-rownum" class="headerlink" title="2.2 rownum"></a>2.2 rownum</h2><h3 id="2-2-1-为何引入rownum"><a href="#2-2-1-为何引入rownum" class="headerlink" title="2.2.1 为何引入rownum"></a>2.2.1 为何引入rownum</h3><p>对于heap表，pg使用tid表示tuple的物理位置，但是对于aocs表，由于压缩的原因，无法确定一个tuple在文件中的物理位置，所以gp引入了rownum表示tuple在文件中的逻辑位置。</p>
<ol>
<li>rownum 是递增的，但可能不连续，不连续的原因是insert时为了效率每次都是生成一批rownum</li>
<li>每个tuple都唯一的对应一个rownum，与tid一样</li>
<li>不同的segfile的tuple rownum单独计算</li>
</ol>
<p>所以在同一个block内，rownum一定是连续的</p>
<ol start="4">
<li>如何使用rownum找到对应的tuple</li>
</ol>
<p>首先block header记录的当前block的第一个rownum和rowcount，所以只需要遍历整个文件，如果rownum 在[firstrownum, firstrownum+rowcount]范围内，则找到tuple对应的 block，遍历block即可。</p>
<h3 id="2-2-2-aocs的tuple-id"><a href="#2-2-2-aocs的tuple-id" class="headerlink" title="2.2.2 aocs的tuple id"></a>2.2.2 aocs的tuple id</h3><p>gp使用AOTupleId 表示tuple id(与pg的tid对应，heap表使用ItemPointer表示tid)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AOTupleId</span><br><span class="line">&#123;</span><br><span class="line">	uint16      bytes_0_1;</span><br><span class="line">	uint16		bytes_2_3;</span><br><span class="line">	uint16		bytes_4_5;</span><br><span class="line"></span><br><span class="line">&#125; AOTupleId;</span><br></pre></td></tr></table></figure>
<p>最左7位是segment no，所以最多只有128文件<br>最右的第16位是保留位，一定是1<br>剩下的40位元组在文件的位置标记，即rownum。<br>如下图所示：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/rownum.png" alt="rownum"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>为什么第33位要标记为1？</strong></li>
</ul>
<p>主要原因是AOTupleId在一些地方如executor等会转换成行存的Itempointer，在代码中有很多ItemPointerIsValid的判断，为了简单gp把第33位标记为1.<br>实际上要过ItemPointerIsValid的判断，只需要把最后16位的任意一位标记为1即可，不确定为什么选择最后16位的第一个位。</p>
<h2 id="2-3-block"><a href="#2-3-block" class="headerlink" title="2.3 block"></a>2.3 block</h2><p>对于列存的block，每个block有2个header，一个是block header，另一个是datum header。其中block header是不会压缩的，datum header会压缩。</p>
<h3 id="2-3-1-header"><a href="#2-3-1-header" class="headerlink" title="2.3.1 header"></a>2.3.1 header</h3><ul>
<li><input checked disabled type="checkbox"> <strong>block header</strong></li>
</ul>
<p>block header size： 8bytes + 8bytes + 4 bytes = 20 bytes<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block-header.png" alt="block header"><br>类型：</p>
<ol>
<li>AoHeaderKind_SmallContent  一般的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AOSmallContentHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      uint32            smallcontent_bytes_0_3;</span><br><span class="line">      uint32            smallcontent_bytes_4_7;</span><br><span class="line">&#125;AOSmallContentHeader</span><br></pre></td></tr></table></figure></li>
<li>AoHeaderKind_LargeContent 超长字段，一个block存不下，分成多个block存储</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AOLargeContentHeader</span><br><span class="line">&#123;</span><br><span class="line">    uint32            largecontent_bytes_0_3;</span><br><span class="line">    uint32            largecontent_bytes_4_7;</span><br><span class="line">&#125;AOLargeContentHeader</span><br></pre></td></tr></table></figure>
<p>如果一个字段长度超长，则会被分割成多个block存储，方式是：<br>large block|small block|…|small block</p>
<ol start="3">
<li>AoHeaderKind_NonBulkDenseContent </li>
</ol>
<p>column compress type = rle_type<br>column compress level = 1 &amp;&amp;<br>rowcount &gt; 16383</p>
<ol start="4">
<li>AoHeaderKind_BulkDenseContent</li>
</ol>
<p>column compress type = rle_type<br>column compress level &gt; 1 &amp;&amp;<br>rowcount &gt; 16383<br><strong>未看到哪种情况会走这个</strong></p>
<p>[x] <strong>datum header</strong><br>类型：</p>
<ol>
<li>DatumStreamVersion_Original</li>
</ol>
<p>无压缩或者zlib压缩</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Datum Stream Block (Original).</span></span><br><span class="line"><span class="comment"> * 16 bytes header.  Followed by data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumStreamBlock_Orig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	int16		version;		<span class="comment">/* version number */</span></span><br><span class="line">	int16		flags;			<span class="comment">/* some flags */</span></span><br><span class="line">	int16		ndatum;			<span class="comment">/* number of datum, including null */</span></span><br><span class="line">	int16		unused;			<span class="comment">/* unused */</span></span><br><span class="line">	int32		nullsz;			<span class="comment">/* size nullbitmaps */</span></span><br><span class="line">	int32		sz;				<span class="comment">/* logical data size, not including header,</span></span><br><span class="line"><span class="comment">								 * nullbitmap, and padding */</span></span><br><span class="line">&#125;	DatumStreamBlock_Orig;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>DatumStreamVersion_Dense</li>
</ol>
<p>目前版本无该类型的block，猜测是用于quicklz压缩的</p>
<ol start="3">
<li>DatumStreamVersion_Dense_Enhanced</li>
</ol>
<p>压缩类型为: RLE_TYPE<br>DatumStreamBlock_Dense<br>DatumStreamBlock_Rle_Extension<br>DatumStreamBlock_Delta_Extension</p>
<h3 id="2-3-2-block-size"><a href="#2-3-2-block-size" class="headerlink" title="2.3.2 block size"></a>2.3.2 block size</h3><p>列存block size 范围：[8KB, 2MB]，压缩之前的size<br>默认size是：32KB<br>真实的block size受限于用户建表时定义的blocksize，如果没有指定blocksize，则使用默认的blocksize。<br>还有一个参数会影响block size，就是gp列存限定了一个block最多可以存多少个value，如果超过这个值，即使没有达到block size限制还是会写入到另外的block内的。</p>
<ol>
<li>DatumStreamVersion_Original</li>
</ol>
<p>最多16383行, 即small content header row count最大值：2^14 - 1</p>
<ol start="2">
<li>DatumStreamVersion_Dense/DatumStreamVersion_Dense_Enhanced</li>
</ol>
<p>最多2^30 -1行, 即noblukdense header row count最大值</p>
<h3 id="2-3-3-null-bitmap"><a href="#2-3-3-null-bitmap" class="headerlink" title="2.3.3 null bitmap"></a>2.3.3 null bitmap</h3><p>用来存储null值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DatumStreamBitMapWrite</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	uint8	   *buffer;</span><br><span class="line">	int32		bufferSize;</span><br><span class="line"></span><br><span class="line">	uint8		byteBit;</span><br><span class="line">	uint8	   *bytePointer;</span><br><span class="line">	int32		bitOnCount;</span><br><span class="line">	int32		bitCount;</span><br><span class="line">&#125;	DatumStreamBitMapWrite;</span><br></pre></td></tr></table></figure>

<h1 id="3-辅助元信息表"><a href="#3-辅助元信息表" class="headerlink" title="3. 辅助元信息表"></a>3. 辅助元信息表</h1><h2 id="3-1-库级别的meta表"><a href="#3-1-库级别的meta表" class="headerlink" title="3.1 库级别的meta表"></a>3.1 库级别的meta表</h2><p>pg_appendonly gp原有的，记录所有的appendonly表<br>gp_fastsequence rownum使用的sequence，segment上的有用</p>
<h2 id="3-2-表级别的meta表"><a href="#3-2-表级别的meta表" class="headerlink" title="3.2 表级别的meta表"></a>3.2 表级别的meta表</h2><p>下面的meta表是对于每个ao表都有，如果表是分区表，则每个自分区也都会有下面这些meta表。</p>
<h3 id="3-2-1-查询方法"><a href="#3-2-1-查询方法" class="headerlink" title="3.2.1 查询方法"></a>3.2.1 查询方法</h3><p>SELECT gp_segment_id, * from gp_dist_random(‘pg_aoseg.pg_aoblkdir_17684’)<br>注意使用utility直接登录segment查询是不行的，估计是可见性问题吧</p>
<h3 id="3-2-2-pg-aocsseg-XXX"><a href="#3-2-2-pg-aocsseg-XXX" class="headerlink" title="3.2.2 pg_aocsseg_XXX"></a>3.2.2 pg_aocsseg_XXX</h3><p>记录segfile 相关信息，包含元组数量、文件长度、修改次数等。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>文件号，表示第几个文件。对应于真实的文件是:</td>
</tr>
<tr>
<td>relfilenode.segno+（column_number - 1）* 128</td>
<td></td>
<td></td>
</tr>
<tr>
<td>比如relfilenode=451012的第二列的segno=2的文件名是：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>451012.130</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tupcount</td>
<td>bigint</td>
<td>元组数量，包含已经删除的和更新的。如果这个值与select count(*)差距比较大的话，就说明垃圾数据较多，需要做vacuum</td>
</tr>
<tr>
<td>varblockcount</td>
<td>bigint</td>
<td></td>
</tr>
<tr>
<td>vpinfo</td>
<td>bytea</td>
<td>记录文件长度，包含真实的eof和未压缩后的eof</td>
</tr>
<tr>
<td>modcount</td>
<td>bigint</td>
<td>文件修改次数</td>
</tr>
<tr>
<td>state</td>
<td>smallint</td>
<td>文件状态：USECURRENT/DEFAULT/AWAITING_DROP</td>
</tr>
</tbody></table>
<p>一个例子：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aocsseg_XXX.png" alt="pg_aocsseg_XXX"></p>
<h3 id="3-2-3-pg-aovisimap-XXX"><a href="#3-2-3-pg-aovisimap-XXX" class="headerlink" title="3.2.3 pg_aovisimap_XXX"></a>3.2.3 pg_aovisimap_XXX</h3><p>记录segfile里面的元组可见性信息，主要作用于update/delete，对于rollback导致的不可见是由pg_aocsseg_xxx里面记录的文件长度保证的。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>segfile number</td>
</tr>
<tr>
<td>first_row_no</td>
<td>bigint</td>
<td>当前范围内的第一个row num，从0开始，每个元组记录32768个元组可见性信息。</td>
</tr>
<tr>
<td>visimap</td>
<td>bit varying</td>
<td>记录元组可见性的bit map</td>
</tr>
</tbody></table>
<p>例子：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pg_aovisimap_XXX.png" alt="pg_aovisimap_XXX"></p>
<p>如何判断一个rownum是否在当前visiMapEntry内：<br>bitoffset = rownum - first_row_no<br>(rownum &gt;= first_row_no &amp;&amp; rownum &lt; first_row_no + 32768) &amp;&amp;  (visimap &amp; (1&lt;&lt;bitoffset) != 0) == true ?</p>
<h3 id="3-2-4-pg-aoblkdir-XXX"><a href="#3-2-4-pg-aoblkdir-XXX" class="headerlink" title="3.2.4 pg_aoblkdir_XXX"></a>3.2.4 pg_aoblkdir_XXX</h3><p>块字典meta表，用于记录block位置信息。创建表的时候，默认不创建该表，在创建表的第一个index时，会创建该meta表。由于ao表的AOTupleId只记录的tuple的逻辑位置信息，不像heap的tid记录的是物理位置信息，在使用index scan时，无法通过AOTupleId直接的找到tuple，所以gp添加了pg_aoblkdir_XXX表，记录block的物理位置信息，来加上index scan tuple的fetch。<br>该系统表上以一个索引，索引列是(segno, columngroup_no, first_row_no)。</p>
<table>
<thead>
<tr>
<th>column</th>
<th>type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>segno</td>
<td>integer</td>
<td>segfile number</td>
</tr>
<tr>
<td>columngroup_no</td>
<td>integer</td>
<td>column number</td>
</tr>
<tr>
<td>first_row_no</td>
<td>bigint</td>
<td>该行覆盖的第一个tuple的rownum</td>
</tr>
<tr>
<td>minipage</td>
<td>bit varying</td>
<td>minEntry的数组，每个entry覆盖多个block</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MinipageEntry</span><br><span class="line">&#123;</span><br><span class="line">	int64 firstRowNum;   &#x2F;&#x2F; 当前entry覆盖的第一个tuple的rownum</span><br><span class="line">	int64 fileOffset;    &#x2F;&#x2F; 当前entry 覆盖的第一个block在文件中的偏移，该偏移是开始位置的偏移</span><br><span class="line">	int64 rowCount;      &#x2F;&#x2F; 当前entry覆盖的所有block的tuple个数 </span><br><span class="line">  										 &#x2F;&#x2F; (可能会比实际的个数要大，因为有些情况是计算出来的)</span><br><span class="line">&#125; MinipageEntry;</span><br><span class="line"></span><br><span class="line">typedef struct Minipage</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* Total length. Must be the first. *&#x2F;</span><br><span class="line">	int32 _len;</span><br><span class="line">	int32 version;</span><br><span class="line">	uint32 nEntry;</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Varlena array *&#x2F;</span><br><span class="line">	MinipageEntry entry[1];</span><br><span class="line">&#125; Minipage;</span><br></pre></td></tr></table></figure>
<p>默认pg_aoblkdir_XXX的一行可以存储161(NUM_MINIPAGE_ENTRIES)个MinipageEntry信息， 每个MinipageEntry记录一个block的信息，但是为了提高性能，gp也提供如下方法来修改一个entry记录的block数量还有一行记录的entry数量：</p>
<ol>
<li>gp_blockdirectory_minipage_size</li>
</ol>
<p>一行记录存储的MinipageEntry数量, 取值范围是(1 .. 161)</p>
<ol start="2">
<li>gp_blockdirectory_entry_min_range</li>
</ol>
<p>控制一个MinipageEntry 记录的数据范围，取值范围（0, INT_MAX）.<br>计算方法：<br>current_fileOffset - last MinipageEntry.fileOffset &lt; gp_blockdirectory_entry_min_range，则跳过当前block，否则把当前block的相关信息记录到新的MinipageEntry。current_fileOffset - last MinipageEntry.fileOffset 表示的就是last MinipageEntry所能覆盖的范围。<br>gp_blockdirectory_entry_min_range参数会导致MinipageEntry的覆盖范围超过一个block，但是不会小于一个block。<br>pg_aoblkdir_XXX的维护：</p>
<ol>
<li>更新<ol>
<li>insert new tuple时，包含update</li>
<li>alter table add column时</li>
<li>build index时，创建新的索引的时候，在scan时会更新pg_aoblkdir_XXX</li>
</ol>
</li>
<li>查询 – index scan， 如何使用pg_aoblkdir_XXX快速定位tuple</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AppendOnlyBlockDirectoryEntry</span><br><span class="line">&#123;</span><br><span class="line">	struct range</span><br><span class="line">	&#123;</span><br><span class="line">		int64		fileOffset;     &#x2F;&#x2F; current MinipageEntry.fileOffset</span><br><span class="line">		int64		firstRowNum;    &#x2F;&#x2F; current MinipageEntry.firstRowNum</span><br><span class="line"></span><br><span class="line">		int64		afterFileOffset;  &#x2F;&#x2F; next MinipageEntry.fileOffset</span><br><span class="line">		int64		lastRowNum;       &#x2F;&#x2F; current MinipageEntry.firstRowNum + current MinipageEntry.rowCount - 1</span><br><span class="line">	&#125; range;</span><br><span class="line">&#125; AppendOnlyBlockDirectoryEntry;</span><br></pre></td></tr></table></figure>
<p>根据AOTupleId，算出segfile number和rownum，使用pg_aoblkdir_XXX上的索引，进行索引扫描（条件：segno=segfile number and columngroup_no = column_no and first_row_no &lt;= rownum）快速定位到 AOTupleId 所在的MiniPage。然后通过二分查找在MiniPage中查找rownum所在的block。找到block后，就可以通过fileseek直接读取block，然后遍历block即可找到对应的tuple。</p>
<h1 id="4-insert-update-delete"><a href="#4-insert-update-delete" class="headerlink" title="4. insert/update/delete"></a>4. insert/update/delete</h1><h2 id="4-1-insert"><a href="#4-1-insert" class="headerlink" title="4.1 insert"></a>4.1 insert</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecInsert&#x2F;CopyFrom</span><br><span class="line">	aocs_insert_init</span><br><span class="line">  aocs_insert_values</span><br><span class="line">  </span><br><span class="line">ExecEndPlan&#x2F;CopyFrom</span><br><span class="line">	aocs_insert_finish</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_init</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化AOCSInsertDesc</span><br><span class="line">open DatumStreams</span><br><span class="line">从gp_fastsequence获取rownum range</span><br><span class="line">初始化fist rownum</span><br><span class="line">初始化AppendOnlyBlockDirectory</span><br></pre></td></tr></table></figure></li>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_values</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for each columns</span><br><span class="line">do</span><br><span class="line">	尝试把value存入当前block</span><br><span class="line">  if failed</span><br><span class="line">  	把当前block写入buffer，并清空当前block</span><br><span class="line">    更新blockDirectory系统表</span><br><span class="line">  	再次尝试把value写入当前block</span><br><span class="line">    if failed</span><br><span class="line"> 			把value分割，写入不同的block(lob，large object)</span><br><span class="line">  		更新blockDirectory系统表</span><br><span class="line">done</span><br><span class="line">set AOTupleId</span><br><span class="line">如 rownum 使用完了，从新从gp_fastsequence获取一批rownum(100)</span><br></pre></td></tr></table></figure>
有几点需要注意的是：</li>
</ul>
<ol>
<li>如果压缩类型是rle_type，则使用lob存储时，不会进行压缩</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_insert_finish</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for each columns</span><br><span class="line">do</span><br><span class="line">	write block to buffer</span><br><span class="line">  update block directory catalog</span><br><span class="line">  close file</span><br><span class="line">  	flush buffer content to disk</span><br><span class="line">    sync content to mirror</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">update aocs file segment information</span><br><span class="line">some cleanup job</span><br></pre></td></tr></table></figure>
<h2 id="4-2-delete"><a href="#4-2-delete" class="headerlink" title="4.2 delete"></a>4.2 delete</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecDelete</span><br><span class="line">	aocs_delete_init</span><br><span class="line">  aocs_delete</span><br><span class="line">  </span><br><span class="line"> ExecEndPlan</span><br><span class="line"> 	aocs_delete_finish</span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_delete_init</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化AOCSDeleteDesc</span><br><span class="line">初始化visibilityMap</span><br><span class="line">初始化visibilityMapDelete</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>aocs_delete</strong><br>比较简单就是把visibilityMap上对应的位置标记为1<br>主要工作在AppendOnlyVisimapDelete_Hide里面完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if tuple不在current_Visimap_Entry内</span><br><span class="line">	if current_Visimap_Entry is dirty</span><br><span class="line">  	把current_Visimap_Entry刷入外存(使用work file组织)</span><br><span class="line">  查找tuple对应的visimap entry并加装到current_Visimap_Entry</span><br><span class="line">标记current_Visimap_Entry 对应的bit为1，并设置为dirty</span><br></pre></td></tr></table></figure>
<p>对于pg_aovisimap_XXX 系统表的修改，gp这里做了一个特殊处理，原有系统表的修改是通过shared_buffer来做的，没改一次要修改一次shared_buffer并记录xlog。这里gp对于pg_aovisimap_XXX 的修改做了优化，把同一条语句内多次修改pg_aovisimap_XXX 的操作合并成了，这样可以减少pg_aovisimap_XXX 的更新次数已经xlog量。合并的方式是：对应pg_aovisimap_XXX 的修改先记录到内存，如果内存放不下，则写入到work file内，在最后语句结束的是在把内存和work file内的修改更新到pg_aovisimap_XXX 上。<br>这样做的出发点：</p>
<ol>
<li>减少pg_aovisimap_XXX由于更新导致的过度膨胀</li>
<li>减少xlog，可以提高mirror同步效率</li>
</ol>
</li>
<li><p><strong>aocs_delete_finish</strong></p>
</li>
</ul>
<p>主要是把内存中的visimap entry 和work file内的entry 合并然后更新到pg_aovisimap_XXX</p>
<h2 id="4-3-update"><a href="#4-3-update" class="headerlink" title="4.3 update"></a>4.3 update</h2><p>update操作实际就是 delete + insert，代码上也基本是这样实现的，没啥好说的。<br>有一点是，虽然是列存，但是update的时候还是按行来做的，即使我们只update某一列，实际上与行存一样，aocs也是把整个行标记为delete，然后insert新的行。</p>
<h2 id="4-4-copy-from"><a href="#4-4-copy-from" class="headerlink" title="4.4 copy from"></a>4.4 copy from</h2><p>与insert 类似</p>
<h2 id="4-5-iud并发控制"><a href="#4-5-iud并发控制" class="headerlink" title="4.5 iud并发控制"></a>4.5 iud并发控制</h2><ul>
<li><input checked disabled type="checkbox"> <strong>update/delete并发控制</strong></li>
</ul>
<p>update/delete并发控制比较简单，在执行时加表的ExclusiveLock, 把update/delete/ select for update操作串行化。<br>这样做的目的主要是防止死锁，由于gp没有全局的死锁检测机制，所以弱化update并发来解决死锁问题。<br>目前gp死锁检测处理不了的情况：<br><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/global-deadlock.png" alt="global-deadlock"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert与insert的并发控制</strong></li>
</ul>
<p>对于同一个表的insert是可以并发执行的，由于列存与pg heap表不同，gp针对列存表单独实现了一个比较简单粗暴的并发控制机制：对于insert操作，每个insert进程处理不同的segfile，即insert 进程直接不会有冲突，所以也不需要加锁等控制。简单来说有2点：</p>
<ol>
<li>对于列存文件的修改，每个insert进程修改不同的segfile</li>
</ol>
<p>在insert之前，gp会为insert进程分配当前进程插入的segfile，不同的insert 进程插入不同的segfile，处理流程可以看一下SetSegnoForWrite函数的实现。</p>
<ol start="2">
<li>对应meta表的修改，走pg heap 表，使用pg原有的并发控制机制</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert与update/delete的并发控制</strong></li>
</ul>
<p>由于update/delete需要加ExclusiveLock锁，导致insert与update/delete也无法并行执行</p>
<h1 id="5-scan"><a href="#5-scan" class="headerlink" title="5. scan"></a>5. scan</h1><h2 id="5-1-table-scan"><a href="#5-1-table-scan" class="headerlink" title="5.1 table scan"></a>5.1 table scan</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aocs_beginscan</span><br><span class="line">while !done</span><br><span class="line">	aocs_getnext</span><br><span class="line">aocs_endscan</span><br></pre></td></tr></table></figure>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_beginscan</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resourceowner table refcount+1</span><br><span class="line">GetAppendOnlyEntry</span><br><span class="line">从pg_aoseg_xxx表查询所有的segfile信息</span><br><span class="line">create AOCSScanDesc</span><br><span class="line">	aocs_initscan</span><br><span class="line">  	open_ds_read</span><br><span class="line">  AppendOnlyVisimap_Init</span><br></pre></td></tr></table></figure>
关于scan时的snapshot：</li>
</ul>
<ol>
<li>current_snapshot， 正常查询的snapshot，scan之前生成</li>
</ol>
<p>tabledata_snapshot: current_snapshot<br>metadata_snapshot: current_snapshot</p>
<ol start="2">
<li>SnapshotAny，开启gp_select_invisible后使用，用于查询历史数据。</li>
</ol>
<p>tabledata_snapshot: SnapshotAny<br>aocs表tuple上是没有事务信息的，这个snapshot主要是用来配合pg_visimap_xxx系统表的<br>metadata_snapshot: current_snapshot</p>
<ul>
<li><p><strong>aocs_endscan</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resourceowner table refcount-1</span><br><span class="line">destory AOCSScanDesc</span><br><span class="line">	close_cur_scan_seg</span><br><span class="line">  close_ds_read</span><br><span class="line">  AppendOnlyVisimap_Finish</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>aocs_getnext</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">READ_NEXT:</span><br><span class="line">	<span class="keyword">if</span> necessary, open next segfile;</span><br><span class="line">    <span class="keyword">if</span> (No more seg)</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  	foreach_columns</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="keyword">if</span> (scan-&gt;proj[i] == <span class="literal">false</span>)</span><br><span class="line">    		<span class="comment">// 查询没有使用到该column，skip read</span></span><br><span class="line">    		<span class="keyword">continue</span>;</span><br><span class="line">      </span><br><span class="line">   		<span class="comment">//当前block的current_tuple 后移，类似于jdbc ResultSet.next</span></span><br><span class="line">    	datumstreamread_advance;</span><br><span class="line">    	<span class="keyword">if</span> (no tuple)</span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="comment">// read next block</span></span><br><span class="line">            datumstreamread_block;</span><br><span class="line">            <span class="keyword">if</span> (end of file)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> READ_NEXT;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> necessary, insert block directory meta entry;</span><br><span class="line">            datumstreamread_advance;</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get current column value</span></span><br><span class="line">        datumstreamread_get</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> AOTupleId</span><br><span class="line">    数据可见性判断，如果不可见 <span class="keyword">goto</span> READ_NEXT;</span><br><span class="line">    save current tuple <span class="keyword">and</span> AOTupleId;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>对于查询未涉及的column，read时自动跳过，减少io</li>
<li>数据可见性判断<ul>
<li>如果tabledata_snapshot是SnapshotAny，则跳过可见性判断</li>
<li>否则，通过visimap判断tuple是否已经被删除</li>
</ul>
</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>aocs_getnext_comp</strong></li>
</ul>
<p>开启向量化后，aocs scan接口。与aocs_getnext的不同之处在于：</p>
<ol>
<li>aocs_getnext每次读取一个tuple，然后就返回，而aocs_getnext_comp是每次读取一批tuple。</li>
<li>对于向量化，会有一些谓词下推，所以aocs_getnext_comp会做一些filter<h2 id="5-2-index-scan"><a href="#5-2-index-scan" class="headerlink" title="5.2 index scan"></a>5.2 index scan</h2>aocs上的索引扫描<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BitmapAppendOnlyScanNext</span><br><span class="line">	aocs_fetch_init</span><br><span class="line">  aocs_fetch</span><br><span class="line">	aocs_fetch_finish</span><br></pre></td></tr></table></figure>
aocs_fetch：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foreach_columns</span><br><span class="line">&#123;</span><br><span class="line">	从BlockDirectoryEntry找到tuple所在block</span><br><span class="line">    从block中读取tuple</span><br><span class="line">    判断tuple可见性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可优化的地方：</p>
<ol>
<li>先做可见性判断在读block</li>
</ol>
<p>目前做可见性判断时是先把tuple所在block 从disk读到内存，然后在判断可见性。实际上aocs的可见性信息是记录在pg_aovisimap表里面的，可以先判断可见性，再读block，这样如果不可见可以减少不必须的io。</p>
<ol start="2">
<li>第一列通过可见性判断后，后面列可以跳过可见性判断</li>
</ol>
<p>rownum是tuple的唯一标识，如果tuple的第一列通过了可见性判断，则后面所有的列也是可见的，因此是不需要再做可见性判断的</p>
<h2 id="5-3-header-scan"><a href="#5-3-header-scan" class="headerlink" title="5.3 header scan"></a>5.3 header scan</h2><p>alter table add column 是调用，粗略看了一下代码，主要是用来辅助创建新的column对应的segfile的。header scan实际上扫描的时候只是把block读取出来，并不会把block解压，主要是使用block上的header信息。<br>有两点：</p>
<ol>
<li>ao表 添加新的column时，必须指定default value</li>
<li>新segfile与之前column的segfile在结构完基本一样，比如每个block记录多少个tuple等<h2 id="5-4-tid-scan"><a href="#5-4-tid-scan" class="headerlink" title="5.4 tid scan"></a>5.4 tid scan</h2>ao表没有tid scan，只有heap表有<h2 id="5-5-range-scan"><a href="#5-5-range-scan" class="headerlink" title="5.5 range scan"></a>5.5 range scan</h2>主要是做compaction 时使用。与 table scan类似，不同之处是每次只扫描指定的几个segfile，而不是扫描所有的segfile。<h1 id="6-事务ACID"><a href="#6-事务ACID" class="headerlink" title="6. 事务ACID"></a>6. 事务ACID</h1>aocs实现了类似heap的mvcc，并且支持完整的事务ACID。aocs表数据分为两种：一是用户数据，二是meta数据。用户数据存储在segfile中，只存储数据，不存储任何事务信息(与heap表不同)，commit之前一定会flush到磁盘；meta数据存储在heap表中，通过分布式事务保证。<br>aocs的实现事务的meta表有2个 pg_aocsseg_xxx和pg_aovisimap_xxx，其中pg_aocsseg_xxx记录数据文件的逻辑长度(即当前事务可以看到的长度)；pg_aovisimap_xxx记录delete tuple，即哪些tuple被删除了。</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>insert</strong></li>
</ul>
<p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/insert.png" alt="insert"></p>
<ul>
<li><input checked disabled type="checkbox"> <strong>update</strong></li>
</ul>
<p><img src="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/update.png" alt="update"></p>
<h1 id="7-aocs-compaction"><a href="#7-aocs-compaction" class="headerlink" title="7. aocs compaction"></a>7. aocs compaction</h1><p>类似于heap表的vacuum，用来清理 delete的tuple或者rollback后残留的tuple。<br>gp对vacuum操作进行了改造，目的是为了适应分布式系统，把原来pg的一个vacuum分成了几个阶段，每个阶段使用一个分布式事务。<br>对于ao表分为4个阶段：</p>
<ol>
<li>prepare phase</li>
</ol>
<p>truncate unnecessary blocks after the logical EOF</p>
<ol start="2">
<li>compaction phase</li>
<li>drop phase</li>
</ol>
<p>删除compaction phase的segfile</p>
<ol start="4">
<li>cleanup phase</li>
</ol>
<p>does normal heap vacuum on auxiliary relations (toast, aoseg, block directory, visimap,) as well as updating stats info in catalog</p>
<p>compaction主要有两种操作：</p>
<ol>
<li>AOCSCompaction_DropSegmentFile</li>
</ol>
<p>删掉AOSEG_STATE_AWAITING_DROP状态的segfile。在vacuum的drop phase做。</p>
<ol start="2">
<li>AOCSTruncateToEOF</li>
</ol>
<p>在不满足compaction条件时，做truncate，这操作主要是清理最近rollback的事务残留在文件尾部的tuple。</p>
<ol start="3">
<li>AOCSSegmentFileFullCompaction</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> 触发sql</li>
</ul>
<p>vacuum<br>vacuum full</p>
<ul>
<li><input checked disabled type="checkbox"> 哪些情况会做</li>
</ul>
<p>AppendOnlyCompaction_ShouldCompact</p>
<ol>
<li>vacuum full 且有delete</li>
<li>删除的tuple所占比例大于gp_appendonly_compaction_threshold</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> 如何做compaction</li>
</ul>
<p>compaction的做法比较简单：</p>
<ol>
<li>选择一个segfile做compaction，然后再选择一个segfile作为insert segfile。</li>
<li>遍历compaction segfile的每个tuple，如果可见(snapshot为SnapshotNow)则插入到insert segfile，如果不可见则删除。</li>
<li>set compaction segfile为AOSEG_STATE_AWAITING_DROP</li>
<li>delete visimap和block directory 中对应segno的数据</li>
</ol>
<p>insert segfile的选择：<br>选择tuple数最小的segfile或者当前vacuum事务正在使用的segfile作为insert segfile。</p>
<ul>
<li><input checked disabled type="checkbox"> 相关guc参数<table>
<thead>
<tr>
<th>参数名</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>gp_appendonly_compaction</td>
<td>是否开启compaction，如果是off，则vacuum时只需TruncateToEOF</td>
</tr>
<tr>
<td>gp_appendonly_compaction_threshold</td>
<td>compaction 的阈值</td>
</tr>
<tr>
<td>Debug_appendonly_print_compaction</td>
<td>输出debug信息</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="8">
<li>aocs表的一些限制</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> <strong>不支持unique index</strong></li>
</ul>
<p>不支持的原因是在检查到冲突的tuple后，无法判断该tuple的事务信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zisedeqing.github.io/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" data-id="ckj8li7y70000qlfy6pgug6xz" data-title="Greenplum 列存原理分析" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aocs/" rel="tag">aocs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/greenplum/" rel="tag">greenplum</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%97%E5%AD%98/" rel="tag">列存</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/12/28/Greenplum-6-0-HA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Greenplum 6.0 HA</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/greenplum/">greenplum</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aocs/" rel="tag">aocs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/greenplum/" rel="tag">greenplum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%97%E5%AD%98/" rel="tag">列存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/28/Greenplum-%E5%88%97%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Greenplum 列存原理分析</a>
          </li>
        
          <li>
            <a href="/2020/12/28/Greenplum-6-0-HA/">Greenplum 6.0 HA</a>
          </li>
        
          <li>
            <a href="/2020/12/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2020 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>